/*
//	Draw each of the objects in the ordered layer clipped to a given rect
void DrawOrderedLayerRect( RECT &rc )
{
	PDispNode	dp;
	PDispNode	*mapptr;
	int			mapskip;
	RECT		grid;
	int			i, j;
	ANIMCELL	*pAnim;
	int			xi1, yi1;								// top left cell coord for pAnim
	
	flagUseOrderNumber = FALSE;
	dlindex = 0;										// clear the display list
	headIndex = -1;
														// compute cell coord grid	
	grid.left = rc.left >> the_map.orderedlayer.cellsize;
	grid.top = rc.top >> the_map.orderedlayer.cellsize;
	grid.right = rc.right >> the_map.orderedlayer.cellsize;
	grid.bottom = rc.bottom >> the_map.orderedlayer.cellsize;

	ASSERT( grid.left >= 0 && grid.top >= 0 );
	mapptr = &(the_map.orderedlayer.cells[(grid.top << the_map.orderedlayer.bitwidth) + grid.left]);
	mapskip = the_map.orderedlayer.width - ( grid.right - grid.left ) - 1;

	for( j = grid.top; j <= grid.bottom; j++ )			// draw each cell in grid
	{
		for( i = grid.left; i <= grid.right; i++ )
		{
			dp = * mapptr++;
			while( dp != NULL )
			{
				// insert the dp if it hasn't already been inserted
				pAnim = dp->pAnim;
				if( !pAnim )
					goto nextnode;
				if( pAnim->flags & ANIM_FLAG_INVISIBLE )
					goto nextnode;
				yi1 = pAnim->wrect.top >> the_map.orderedlayer.cellsize;
				if( yi1 < j )
					if( j > grid.top )
						goto nextnode;
				xi1 = pAnim->wrect.left >> the_map.orderedlayer.cellsize;
				if( xi1 < i )
					if( i > grid.left )
						goto nextnode;

				InsertInDispList( pAnim, rc );
nextnode:
				dp = dp->next;
			}
		}
		mapptr += mapskip;
	}

	//	draw the disp list
	if( headIndex == -1 )
		return;
	dp = &(displist[headIndex]);
	while( dp != NULL )
	{
		DrawAnimInRect( dp->pAnim, rc );
		dp = dp->next;
	}
}


//	Draw each of the objects in the top layer clipped to a given rect
void DrawTopLayerRect( RECT &rc )
{
	PDispNode	dp;
	PDispNode	*mapptr;
	int			mapskip;
	RECT		grid;
	int			i, j;
	ANIMCELL	*pAnim;
	int			xi1, yi1;								// top left cell coord for pAnim
	
	flagUseOrderNumber = TRUE;
	dlindex = 0;										// clear the display list
	headIndex = -1;
														// compute cell coord grid	
	grid.left = rc.left >> the_map.toplayer.cellsize;
	grid.top = rc.top >> the_map.toplayer.cellsize;
	grid.right = rc.right >> the_map.toplayer.cellsize;
	grid.bottom = rc.bottom >> the_map.toplayer.cellsize;

	ASSERT( grid.left >= 0 && grid.top >= 0 );
	mapptr = &(the_map.toplayer.cells[(grid.top << the_map.toplayer.bitwidth) + grid.left]);
	mapskip = the_map.toplayer.width - ( grid.right - grid.left ) - 1;

	for( j = grid.top; j <= grid.bottom; j++ )			// draw each cell in grid
	{
		for( i = grid.left; i <= grid.right; i++ )
		{
			dp = * mapptr++;
			while( dp != NULL )
			{
				// insert the dp if it hasn't already been inserted
				pAnim = dp->pAnim;
				if( !pAnim )
					goto nextnode;
				if( pAnim->flags & ANIM_FLAG_INVISIBLE )
					goto nextnode;
				yi1 = pAnim->wrect.top >> the_map.toplayer.cellsize;
				if( yi1 < j )
					if( j > grid.top )
						goto nextnode;
				xi1 = pAnim->wrect.left >> the_map.toplayer.cellsize;
				if( xi1 < i )
					if( i > grid.left )
						goto nextnode;

				InsertInDispList( pAnim, rc );
nextnode:
				dp = dp->next;
			}
		}
		mapptr += mapskip;
	}

	//	draw the disp list
	if( headIndex == -1 )
		return;
	dp = &(displist[headIndex]);
	while( dp != NULL )
	{
		DrawAnimInRect( dp->pAnim, rc );
		dp = dp->next;
	}
}	//	DrawTopLayerRect
*/


/*
//	insert an anim object into a groundlayer display list
void InsertAnimInGroundLayerCell( TDispNode &dnode, PDispNode *displist )
{
	if( *displist == NULL )
	{
		*displist = &dnode;
		dnode.prev = dnode.next = NULL;
		return;
	}
	else
	{
		PDispNode dp;

		dp = *displist;
		if( OrderingFunction( dnode.pAnim, dp->pAnim ) <= 0 )
		{
			dnode.prev = NULL;
			dnode.next = dp;
			dp->prev = &dnode;
			*displist = &dnode;
			return;
		}
		else
		{
			do
			{
				if( dp->next == NULL )
				{
					dp->next = &dnode;
					dnode.prev = dp;
					dnode.next = NULL;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	insert before dp (dp is guaranteed to not be the head
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev = &dnode;
			dnode.prev->next = &dnode;			
		}
	}
}	//	InsertAnimInGroundLayerCell


//	insert an anim object into the ground layer
//	NOTE: all double-shift operations can be optimized into single shift with AND.
void InsertAnimInGroundLayer( PAnim pAnim )
{
	int i, j, f, idx, l;
	int yi1, yi2, xi1, xi2;

	// compute the 4 corner cells for the anim

	xi1 = pAnim->wrect.left >> the_map.groundlayer.cellsize;
	yi1 = pAnim->wrect.top >> the_map.groundlayer.cellsize;
	xi2 = pAnim->wrect.right >> the_map.groundlayer.cellsize;
	yi2 = pAnim->wrect.bottom >> the_map.groundlayer.cellsize;
	f = 0;
	idx = (yi1 << the_map.groundlayer.bitwidth) + xi1;

	ASSERT( idx >= 0 );
	ASSERT( ((yi2 << the_map.groundlayer.bitwidth) + xi2) < 
		    (the_map.groundlayer.height << the_map.groundlayer.bitwidth) );

	l = the_map.groundlayer.width - ( xi2 - xi1 + 1 );
	// insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			pAnim->feet[f].index = idx;
			InsertAnimInGroundLayerCell( pAnim->feet[f].dnode, the_map.groundlayer.cells + idx );
			f++;
			idx++;
		}
		idx += l;
	}

	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		pAnim->feet[f].index = -1;
		pAnim->feet[f].dnode.prev = pAnim->feet[f].dnode.next = NULL;
		f++;
	}
}	//	InsertAnimInGroundLayer


//	insert an anim object into a orderedlayer display list
void InsertAnimInOrderedLayerCell( TDispNode &dnode, PDispNode *displist )
{
	if( *displist == NULL )
	{
		*displist = &dnode;
		dnode.prev = dnode.next = NULL;
		return;
	}
	else
	{
		PDispNode dp;

		dp = *displist;
		if( OrderingFunction( dnode.pAnim, dp->pAnim ) <= 0 )
		{
			dnode.prev = NULL;
			dnode.next = dp;
			dp->prev = &dnode;
			*displist = &dnode;
			return;
		}
		else
		{
			do
			{
				if( dp->next == NULL )
				{
					dp->next = &dnode;
					dnode.prev = dp;
					dnode.next = NULL;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	insert before dp (dp is guaranteed to not be the head
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev = &dnode;
			dnode.prev->next = &dnode;			
		}
	}
}	//	InsertAnimInOrderedLayerCell


//	insert an anim object into the middle layer
void InsertAnimInOrderedLayer( PAnim pAnim )
{
	int i, j, f, idx, l;
	int yi1, yi2, xi1, xi2;

	// compute the 4 corner cells for the anim

	xi1 = pAnim->wrect.left >> the_map.orderedlayer.cellsize;
	yi1 = pAnim->wrect.top >> the_map.orderedlayer.cellsize;
	xi2 = pAnim->wrect.right >> the_map.orderedlayer.cellsize;
	yi2 = pAnim->wrect.bottom >> the_map.orderedlayer.cellsize;
	f = 0;
	idx = (yi1 << the_map.orderedlayer.bitwidth) + xi1;
	l = the_map.orderedlayer.width - ( xi2 - xi1 + 1 );

	ASSERT( idx >= 0 );
	ASSERT( ((yi2 << the_map.orderedlayer.bitwidth) + xi2) < 
		    (the_map.orderedlayer.height << the_map.orderedlayer.bitwidth) );

	// insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			pAnim->feet[f].index = idx;
			InsertAnimInOrderedLayerCell( pAnim->feet[f].dnode, the_map.orderedlayer.cells + idx );
			f++;
			idx++;
		}
		idx += l;
	}
	
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		pAnim->feet[f].index = -1;
		pAnim->feet[f].dnode.prev = pAnim->feet[f].dnode.next = NULL;
		f++;
	}
}	//	InsertAnimInOrderedLayer


//	insert an anim object into a toplayer display list
void InsertAnimInTopLayerCell( TDispNode &dnode, PDispNode *displist )
{
	if( *displist == NULL )
	{
		*displist = &dnode;
		dnode.prev = dnode.next = NULL;
		return;
	}
	else
	{
		PDispNode dp;

		dp = *displist;
		if( OrderingFunction( dnode.pAnim, dp->pAnim ) <= 0 )
		{
			dnode.prev = NULL;
			dnode.next = dp;
			dp->prev = &dnode;
			*displist = &dnode;
			return;
		}
		else
		{
			do
			{
				if( dp->next == NULL )
				{
					dp->next = &dnode;
					dnode.prev = dp;
					dnode.next = NULL;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	insert before dp (dp is guaranteed to not be the head
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev = &dnode;
			dnode.prev->next = &dnode;			
		}
	}
}	//	InsertAnimInTopLayerCell


//	insert an anim object into the middle layer
void InsertAnimInTopLayer( PAnim pAnim )
{
	int i, j, f, idx, l;
	int yi1, yi2, xi1, xi2;

	// compute the 4 corner cells for the anim

	xi1 = pAnim->wrect.left >> the_map.toplayer.cellsize;
	yi1 = pAnim->wrect.top >> the_map.toplayer.cellsize;
	xi2 = pAnim->wrect.right >> the_map.toplayer.cellsize;
	yi2 = pAnim->wrect.bottom >> the_map.toplayer.cellsize;
	f = 0;
	idx = (yi1 << the_map.toplayer.bitwidth) + xi1;
	l = the_map.toplayer.width - ( xi2 - xi1 + 1 );

	ASSERT( idx >= 0 );
	ASSERT( ((yi2 << the_map.toplayer.bitwidth) + xi2) < 
		    (the_map.toplayer.height << the_map.toplayer.bitwidth) );

	// insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			pAnim->feet[f].index = idx;
			InsertAnimInTopLayerCell( pAnim->feet[f].dnode, the_map.toplayer.cells + idx );
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		pAnim->feet[f].index = -1;
		pAnim->feet[f].dnode.prev = pAnim->feet[f].dnode.next = NULL;
		f++;
	}
}	//	InsertAnimInTopLayer


//	insert an anim object into a overlaylayer display list
void InsertAnimInOverlayLayerCell( TDispNode &dnode, PDispNode *displist )
{
	if( *displist == NULL )
	{
		*displist = &dnode;
		dnode.prev = dnode.next = NULL;
		return;
	}
	else
	{
		PDispNode dp;

		dp = *displist;
		if( OrderingFunction( dnode.pAnim, dp->pAnim ) <= 0 )
		{
			dnode.prev = NULL;
			dnode.next = dp;
			dp->prev = &dnode;
			*displist = &dnode;
			return;
		}
		else
		{
			do
			{
				if( dp->next == NULL )
				{
					dp->next = &dnode;
					dnode.prev = dp;
					dnode.next = NULL;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	insert before dp (dp is guaranteed to not be the head
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev = &dnode;
			dnode.prev->next = &dnode;			
		}
	}
}	//	InsertAnimInOverlayLayerCell


//	insert an anim object into the overlay layer
void InsertAnimInOverlayLayer( PAnim pAnim )
{
	int i, j, f, idx, l;
	int yi1, yi2, xi1, xi2;

	// compute the 4 corner cells for the anim

	xi1 = pAnim->wrect.left >> the_map.overlaylayer.cellsize;
	yi1 = pAnim->wrect.top >> the_map.overlaylayer.cellsize;
	xi2 = pAnim->wrect.right >> the_map.overlaylayer.cellsize;
	yi2 = pAnim->wrect.bottom >> the_map.overlaylayer.cellsize;
	f = 0;
	idx = (yi1 << the_map.overlaylayer.bitwidth) + xi1;
	l = the_map.overlaylayer.width - ( xi2 - xi1 + 1 );

	ASSERT( idx >= 0 );
	ASSERT( ((yi2 << the_map.overlaylayer.bitwidth) + xi2) < 
		    (the_map.overlaylayer.height << the_map.overlaylayer.bitwidth) );

	// insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			pAnim->feet[f].index = idx;
			InsertAnimInOverlayLayerCell( pAnim->feet[f].dnode, the_map.overlaylayer.cells + idx );
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		pAnim->feet[f].index = -1;
		pAnim->feet[f].dnode.prev = pAnim->feet[f].dnode.next = NULL;
		f++;
	}
}	//	InsertAnimInOverlayLayer


//	reorder a display node within its display list
void ReorderGroundLayerDisplayList( TDispNode &dnode, PDispNode *dlist )
{
	PDispNode dp;

	if( dnode.next != NULL )	
		if( OrderingFunction( dnode.pAnim, dnode.next->pAnim ) > 0 )
		{
			dp = dnode.next;
			do
			{
				if( dp->next == NULL )
				{
					//	move dnode to end
					if( dnode.prev == NULL )					
						*dlist = dnode.next;
					else
						dnode.prev->next = dnode.next;
					dnode.next->prev = dnode.prev;
					dnode.prev = dp;
					dnode.next = NULL;
					dp->next = &dnode;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	move dnode to be between dp->prev & dp
			if( dnode.prev == NULL )
				*dlist = dnode.next;
			else
				dnode.prev->next = dnode.next;
			dnode.next->prev = dnode.prev;
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev->next = &dnode;
			dp->prev = &dnode;
			return;
		}
	if( dnode.prev != NULL )
		if( OrderingFunction( dnode.pAnim, dnode.prev->pAnim ) < 0 )
		{
			dp = dnode.prev;
			do
			{
				if( dp->prev == NULL )
				{
					// move dnode to beginning
					dnode.prev->next = dnode.next;
					if( dnode.next != NULL )
						dnode.next->prev = dnode.prev;
					dnode.prev = NULL;
					dnode.next = dp;
					dp->prev = &dnode;
					*dlist = &dnode;
					return;
				}
				dp = dp->prev;
			}  while( OrderingFunction( dnode.pAnim, dp->pAnim ) < 0 );
			//	move dnode to be between dp & dp->next
			dnode.prev->next = dnode.next;
			if( dnode.next != NULL )
				dnode.next->prev = dnode.prev;
			dnode.prev = dp;
			dnode.next = dp->next;
			dp->next->prev = &dnode;
			dp->next = &dnode;
			return;
		}
}	//	ReorderGroundLayerDisplayList


//	reorder a display node within its display list
void ReorderOrderedLayerDisplayList( TDispNode &dnode, PDispNode *dlist )
{
	PDispNode dp;

	if( dnode.next != NULL )	
		if( OrderingFunction( dnode.pAnim, dnode.next->pAnim ) > 0 )
		{
			dp = dnode.next;
			do
			{
				if( dp->next == NULL )
				{
					//	move dnode to end
					if( dnode.prev == NULL )					
						*dlist = dnode.next;
					else
						dnode.prev->next = dnode.next;
					dnode.next->prev = dnode.prev;
					dnode.prev = dp;
					dnode.next = NULL;
					dp->next = &dnode;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	move dnode to be between dp->prev & dp
			if( dnode.prev == NULL )
				*dlist = dnode.next;
			else
				dnode.prev->next = dnode.next;
			dnode.next->prev = dnode.prev;
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev->next = &dnode;
			dp->prev = &dnode;
			return;
		}
	if( dnode.prev != NULL )
		if( OrderingFunction( dnode.pAnim, dnode.prev->pAnim ) < 0 )
		{
			dp = dnode.prev;
			do
			{
				if( dp->prev == NULL )
				{
					// move dnode to beginning
					dnode.prev->next = dnode.next;
					if( dnode.next != NULL )
						dnode.next->prev = dnode.prev;
					dnode.prev = NULL;
					dnode.next = dp;
					dp->prev = &dnode;
					*dlist = &dnode;
					return;
				}
				dp = dp->prev;
			}  while( OrderingFunction( dnode.pAnim, dp->pAnim ) < 0 );
			//	move dnode to be between dp & dp->next
			dnode.prev->next = dnode.next;
			if( dnode.next != NULL )
				dnode.next->prev = dnode.prev;
			dnode.prev = dp;
			dnode.next = dp->next;
			dp->next->prev = &dnode;
			dp->next = &dnode;
			return;
		}
}	//	ReorderOrderedLayerDisplayList


//	reorder a display node within its display list
void ReorderTopLayerDisplayList( TDispNode &dnode, PDispNode *dlist )
{
	PDispNode dp;

	if( dnode.next != NULL )	
		if( OrderingFunction( dnode.pAnim, dnode.next->pAnim ) > 0 )
		{
			dp = dnode.next;
			do
			{
				if( dp->next == NULL )
				{
					//	move dnode to end
					if( dnode.prev == NULL )					
						*dlist = dnode.next;
					else
						dnode.prev->next = dnode.next;
					dnode.next->prev = dnode.prev;
					dnode.prev = dp;
					dnode.next = NULL;
					dp->next = &dnode;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	move dnode to be between dp->prev & dp
			if( dnode.prev == NULL )
				*dlist = dnode.next;
			else
				dnode.prev->next = dnode.next;
			dnode.next->prev = dnode.prev;
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev->next = &dnode;
			dp->prev = &dnode;
			return;
		}
	if( dnode.prev != NULL )
		if( OrderingFunction( dnode.pAnim, dnode.prev->pAnim ) < 0 )
		{
			dp = dnode.prev;
			do
			{
				if( dp->prev == NULL )
				{
					// move dnode to beginning
					dnode.prev->next = dnode.next;
					if( dnode.next != NULL )
						dnode.next->prev = dnode.prev;
					dnode.prev = NULL;
					dnode.next = dp;
					dp->prev = &dnode;
					*dlist = &dnode;
					return;
				}
				dp = dp->prev;
			}  while( OrderingFunction( dnode.pAnim, dp->pAnim ) < 0 );
			//	move dnode to be between dp & dp->next
			dnode.prev->next = dnode.next;
			if( dnode.next != NULL )
				dnode.next->prev = dnode.prev;
			dnode.prev = dp;
			dnode.next = dp->next;
			dp->next->prev = &dnode;
			dp->next = &dnode;
			return;
		}
}	//	ReorderTopLayerDisplayList


//	reorder a display node within its display list
void ReorderOverlayLayerDisplayList( TDispNode &dnode, PDispNode *dlist )
{
	PDispNode dp;

	if( dnode.next != NULL )	
		if( OrderingFunction( dnode.pAnim, dnode.next->pAnim ) > 0 )
		{
			dp = dnode.next;
			do
			{
				if( dp->next == NULL )
				{
					//	move dnode to end
					if( dnode.prev == NULL )					
						*dlist = dnode.next;
					else
						dnode.prev->next = dnode.next;
					dnode.next->prev = dnode.prev;
					dnode.prev = dp;
					dnode.next = NULL;
					dp->next = &dnode;
					return;
				}
				dp = dp->next;
			} while( OrderingFunction( dnode.pAnim, dp->pAnim ) > 0 );
			//	move dnode to be between dp->prev & dp
			if( dnode.prev == NULL )
				*dlist = dnode.next;
			else
				dnode.prev->next = dnode.next;
			dnode.next->prev = dnode.prev;
			dnode.prev = dp->prev;
			dnode.next = dp;
			dp->prev->next = &dnode;
			dp->prev = &dnode;
			return;
		}
	if( dnode.prev != NULL )
		if( OrderingFunction( dnode.pAnim, dnode.prev->pAnim ) < 0 )
		{
			dp = dnode.prev;
			do
			{
				if( dp->prev == NULL )
				{
					// move dnode to beginning
					dnode.prev->next = dnode.next;
					if( dnode.next != NULL )
						dnode.next->prev = dnode.prev;
					dnode.prev = NULL;
					dnode.next = dp;
					dp->prev = &dnode;
					*dlist = &dnode;
					return;
				}
				dp = dp->prev;
			}  while( OrderingFunction( dnode.pAnim, dp->pAnim ) < 0 );
			//	move dnode to be between dp & dp->next
			dnode.prev->next = dnode.next;
			if( dnode.next != NULL )
				dnode.next->prev = dnode.prev;
			dnode.prev = dp;
			dnode.next = dp->next;
			dp->next->prev = &dnode;
			dp->next = &dnode;
			return;
		}
}	//	ReorderOverlayLayerDisplayList


//	moves an ground layer object & updates the UpdateRectList (we re-check each corner since item could
//	have changed size!
void MoveObjectInGroundLayer( PAnim pAnim, BOOL ForceUpdate )
{
	int i, j, idx, f, l;
	int	x, y;
	int yi1, yi2, xi1, xi2;
	int	width, height, cellsize;
	PSPRITE pSprite;

	flagUseOrderNumber = TRUE;
	if( !(pAnim->flags & ANIM_FLAG_ACTIVE)	)
	{
		//	get rid of inactive sprite
		if( pAnim->num_feet > 0 )
		{
			if( pAnim->feet[0].index >= 0 )
			{
				InsertRectInUpdateList( pAnim->wrect );
				i = 0;
				while( (i < pAnim->num_feet) && (pAnim->feet[i].index >= 0) )
				{
					RemoveFromDisplayList( pAnim->feet[i].dnode, the_map.groundlayer.cells + pAnim->feet[i].index );
					pAnim->feet[i].index = -1;
					i++;
				}
			}
		}
		return;
	}

 	if( (!ForceUpdate) &&
		(pAnim->world_pos.x == pAnim->old_world_pos.x) &&
		(pAnim->world_pos.y == pAnim->old_world_pos.y) &&
		(pAnim->pSprite == pAnim->prevSprite) )
		return;
	if( !(pAnim->pSprite) )
		return;

	// redraw old rectangle
	InsertRectInUpdateList( pAnim->wrect );

	// calculate position & dimensions of new rectangle
	pSprite = pAnim->pSprite;
	if( !(pAnim->flags & ANIM_FLAG_CELL) )
	{
		if( ((ANIM *)pAnim)->pFrame )
		{
			pSprite->hotspot.x = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.x;
			pSprite->hotspot.y = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.y;
		}
	}
	width = pSprite->srect.right;
	height = pSprite->srect.bottom;
	pAnim->wrect.left = pAnim->world_pos.x - pSprite->hotspot.x;
	pAnim->wrect.top = pAnim->world_pos.y - pSprite->hotspot.y - pAnim->world_z;
	pAnim->wrect.right = pAnim->wrect.left + width;
	pAnim->wrect.bottom = pAnim->wrect.top + height;
	x = pAnim->wrect.left;
	y = pAnim->wrect.top;

	//	compute 4 corners of anim
	cellsize = the_map.groundlayer.cellsize;
	xi1 = x >> cellsize;
	yi1 = ( y >> cellsize );
	xi2 = ( x + width ) >> cellsize;
	yi2 = (( y + height ) >> cellsize);
	ASSERT( (yi1 << the_map.groundlayer.bitwidth) + xi1 >= 0 );
	ASSERT( (yi2 << the_map.groundlayer.bitwidth) + xi2 < (the_map.groundlayer.height << the_map.groundlayer.bitwidth) );

	f = 0;
	idx = (yi1 << the_map.groundlayer.bitwidth) + xi1;
	l = the_map.groundlayer.width - ( xi2 - xi1 + 1 );
	// re-order or insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			ASSERT( f < pAnim->num_feet );
			if( (pAnim->feet[f].index >= 0) && (pAnim->feet[f].index == idx) )
				ReorderGroundLayerDisplayList( pAnim->feet[f].dnode, the_map.groundlayer.cells + idx );
			else
			{
				if( pAnim->feet[f].index >= 0 )
					RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.groundlayer.cells + pAnim->feet[f].index );
				pAnim->feet[f].index = idx;
				InsertAnimInGroundLayerCell( pAnim->feet[f].dnode, the_map.groundlayer.cells + idx );
			}
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		if( pAnim->feet[f].index >= 0 )
			RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.groundlayer.cells + pAnim->feet[f].index );
		else
			break;
		pAnim->feet[f].index = -1;
		f++;
	}
	
	RECT rc;
	rc.left = pAnim->wrect.left;
	rc.top = pAnim->wrect.top;
	rc.right = pAnim->wrect.right;
	rc.bottom = pAnim->wrect.bottom;
	InsertRectInUpdateList( rc );
}	//	MoveObjectInGroundLayer


//	moves an ordered layer object & updates the UpdateRectList (we re-check each corner since item could
//	have changed size!
void MoveObjectInOrderedLayer( PAnim pAnim, BOOL ForceUpdate )
{
	int i, j, idx, f, l;
	int	x, y;
	int yi1, yi2, xi1, xi2;
	int	width, height;
	PSPRITE pSprite;

	flagUseOrderNumber = FALSE;
	if( !(pAnim->flags & ANIM_FLAG_ACTIVE)	)
	{
		//	get rid of inactive sprite
		if( pAnim->num_feet > 0 )
		{
			if( pAnim->feet[0].index >= 0 )
			{
				InsertRectInUpdateList( pAnim->wrect );
				i = 0;
				while( (i < pAnim->num_feet) && (pAnim->feet[i].index >= 0) )
				{
					RemoveFromDisplayList( pAnim->feet[i].dnode, the_map.orderedlayer.cells + pAnim->feet[i].index );
					pAnim->feet[i].index = -1;
					i++;
				}
			}
		}
		return;
	}
 	if( (!ForceUpdate) &&
		(pAnim->world_pos.x == pAnim->old_world_pos.x) &&
		(pAnim->world_pos.y == pAnim->old_world_pos.y) &&
		(pAnim->pSprite == pAnim->prevSprite) )
		return;
	if( !(pAnim->pSprite) )
		return;

	// redraw old rectangle
	InsertRectInUpdateList( pAnim->wrect );

	// calculate position & dimensions of new rectangle
	pSprite = pAnim->pSprite;
	if( !(pAnim->flags & ANIM_FLAG_CELL) )
	{
		if( ((ANIM *)pAnim)->pFrame )
		{
			pSprite->hotspot.x = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.x;
			pSprite->hotspot.y = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.y;
		}
	}
	width = pSprite->srect.right;
	height = pSprite->srect.bottom;
	pAnim->wrect.left = pAnim->world_pos.x - pSprite->hotspot.x;
	pAnim->wrect.top = pAnim->world_pos.y - pSprite->hotspot.y - pAnim->world_z;
	pAnim->wrect.right = pAnim->wrect.left + width;
	pAnim->wrect.bottom = pAnim->wrect.top + height;
	x = pAnim->wrect.left;
	y = pAnim->wrect.top;

	//	compute 4 corners of anim
	xi1 = x >> the_map.orderedlayer.cellsize;
	yi1 = ( y >> the_map.orderedlayer.cellsize );
	xi2 = ( x + width ) >> the_map.orderedlayer.cellsize;
	yi2 = (( y + height ) >> the_map.orderedlayer.cellsize);
	ASSERT( (yi1 << the_map.orderedlayer.bitwidth) + xi1 >= 0 );
	ASSERT( (yi2 << the_map.orderedlayer.bitwidth) + xi2 < (the_map.orderedlayer.height << the_map.orderedlayer.bitwidth) );

	f = 0;
	idx = (yi1 << the_map.orderedlayer.bitwidth) + xi1;
	l = the_map.orderedlayer.width - ( xi2 - xi1 + 1 );
	// re-order or insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			ASSERT( f < pAnim->num_feet );
			if( (pAnim->feet[f].index >= 0) && (pAnim->feet[f].index == idx) )
				ReorderOrderedLayerDisplayList( pAnim->feet[f].dnode, the_map.orderedlayer.cells + idx );
			else
			{
				if( pAnim->feet[f].index >= 0 )
					RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.orderedlayer.cells + pAnim->feet[f].index );
				pAnim->feet[f].index = idx;
				InsertAnimInOrderedLayerCell( pAnim->feet[f].dnode, the_map.orderedlayer.cells + idx );
			}
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		if( pAnim->feet[f].index >= 0 )
			RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.orderedlayer.cells + pAnim->feet[f].index );
		else
			break;
		pAnim->feet[f].index = -1;
		f++;
	}
	
	RECT rc;
	rc.left = pAnim->wrect.left;
	rc.top = pAnim->wrect.top;
	rc.right = pAnim->wrect.right;
	rc.bottom = pAnim->wrect.bottom;
	InsertRectInUpdateList( rc );
}	//	MoveObjectInOrderedLayer


//	moves an top layer object & updates the UpdateRectList (we re-check each corner since item could
//	have changed size!
void MoveObjectInTopLayer( PAnim pAnim, BOOL ForceUpdate )
{
	int i, j, idx, f, l;
	int	x, y;
	int yi1, yi2, xi1, xi2;
	int	width, height;
	PSPRITE pSprite;

	flagUseOrderNumber = TRUE;
	if( !(pAnim->flags & ANIM_FLAG_ACTIVE)	)
	{
		//	get rid of inactive sprite
		if( pAnim->num_feet > 0 )
		{
			if( pAnim->feet[0].index >= 0 )
			{
				InsertRectInUpdateList( pAnim->wrect );
				i = 0;
				while( (i < pAnim->num_feet) && (pAnim->feet[i].index >= 0) )
				{
					RemoveFromDisplayList( pAnim->feet[i].dnode, the_map.toplayer.cells + pAnim->feet[i].index );
					pAnim->feet[i].index = -1;
					i++;
				}
			}
		}
		return;
	}
 	if( (!ForceUpdate) &&
		(pAnim->world_pos.x == pAnim->old_world_pos.x) &&
		(pAnim->world_pos.y == pAnim->old_world_pos.y) &&
		(pAnim->pSprite == pAnim->prevSprite) )
		return;
	if( !(pAnim->pSprite) )
		return;

	// redraw old rectangle
	InsertRectInUpdateList( pAnim->wrect );

	// calculate position & dimensions of new rectangle
	pSprite = pAnim->pSprite;
	if( !(pAnim->flags & ANIM_FLAG_CELL) )
	{
		if( ((ANIM *)pAnim)->pFrame )
		{
			pSprite->hotspot.x = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.x;
			pSprite->hotspot.y = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.y;
		}
	}
	width = pSprite->srect.right;
	height = pSprite->srect.bottom;
	pAnim->wrect.left = pAnim->world_pos.x - pSprite->hotspot.x;
	pAnim->wrect.top = pAnim->world_pos.y - pSprite->hotspot.y - pAnim->world_z;
	pAnim->wrect.right = pAnim->wrect.left + width;
	pAnim->wrect.bottom = pAnim->wrect.top + height;
	x = pAnim->wrect.left;
	y = pAnim->wrect.top;

	//	compute 4 corners of anim
	xi1 = x >> the_map.toplayer.cellsize;
	yi1 = ( y >> the_map.toplayer.cellsize );
	xi2 = ( x + width ) >> the_map.toplayer.cellsize;
	yi2 = (( y + height ) >> the_map.toplayer.cellsize);
	ASSERT( yi1 + xi1 >= 0 );
	ASSERT( (yi2 << the_map.toplayer.bitwidth) + xi2 < (the_map.toplayer.height << the_map.toplayer.bitwidth) );

	f = 0;
	idx = (yi1 << the_map.toplayer.bitwidth) + xi1;
	l = the_map.toplayer.width - ( xi2 - xi1 + 1 );
	// re-order or insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			if( (pAnim->feet[f].index >= 0) && (pAnim->feet[f].index == idx) )
				ReorderTopLayerDisplayList( pAnim->feet[f].dnode, the_map.toplayer.cells + idx );
			else
			{
				if( pAnim->feet[f].index >= 0 )
					RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.toplayer.cells + pAnim->feet[f].index );
				pAnim->feet[f].index = idx;
				InsertAnimInTopLayerCell( pAnim->feet[f].dnode, the_map.toplayer.cells + idx );
			}
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		if( pAnim->feet[f].index >= 0 )
			RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.toplayer.cells + pAnim->feet[f].index );
		else
			break;
		pAnim->feet[f].index = -1;
		f++;
	}
	
	RECT rc;
	rc.left = pAnim->wrect.left;
	rc.top = pAnim->wrect.top;
	rc.right = pAnim->wrect.right;
	rc.bottom = pAnim->wrect.bottom;
	InsertRectInUpdateList( rc );
}	//	MoveObjectInTopLayer


//	moves an top layer object & updates the UpdateRectList (we re-check each corner since item could
//	have changed size!
void MoveObjectInOverlayLayer( PAnim pAnim )
{
	int i, j, idx, f, l;
	int	x, y;
	int yi1, yi2, xi1, xi2;
	int	width, height;
	PSPRITE pSprite;

	flagUseOrderNumber = FALSE;
	if( !(pAnim->flags & ANIM_FLAG_ACTIVE)	)
	{
		//	get rid of inactive sprite
		if( pAnim->num_feet > 0 )
		{
			if( pAnim->feet[0].index >= 0 )
			{
				//	InsertRectInUpdateList( pAnim->wrect );
				i = 0;
				while( (i < pAnim->num_feet) && (pAnim->feet[i].index >= 0) )
				{
					RemoveFromDisplayList( pAnim->feet[i].dnode, the_map.overlaylayer.cells + pAnim->feet[i].index );
					pAnim->feet[i].index = -1;
					i++;
				}
			}
		}
		return;
	}
	if( !(pAnim->pSprite) )
		return;

	//	InsertRectInUpdateList( pAnim->wrect );

	// calculate position & dimensions of new rectangle
	pSprite = pAnim->pSprite;
	if( !(pAnim->flags & ANIM_FLAG_CELL) )
	{
		if( ((ANIM *)pAnim)->pFrame )
		{
			pSprite->hotspot.x = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.x;
			pSprite->hotspot.y = ((ANIM *)pAnim)->pFrame[((ANIM *)pAnim)->current_frame].primary_hotspot.y;
		}
	}
	width = pSprite->srect.right;
	height = pSprite->srect.bottom;
	pAnim->wrect.left = pAnim->world_pos.x - pSprite->hotspot.x;
	pAnim->wrect.top = pAnim->world_pos.y - pSprite->hotspot.y - pAnim->world_z;
	pAnim->wrect.right = pAnim->wrect.left + width;
	pAnim->wrect.bottom = pAnim->wrect.top + height;
	x = pAnim->wrect.left;
	y = pAnim->wrect.top;

	//	compute 4 corners of anim
	xi1 = x >> the_map.overlaylayer.cellsize;
	yi1 = ( y >> the_map.overlaylayer.cellsize );
	xi2 = ( x + width ) >> the_map.overlaylayer.cellsize;
	yi2 = (( y + height ) >> the_map.overlaylayer.cellsize);
	ASSERT( yi1 + xi1 >= 0 );
	ASSERT( (yi2 << the_map.overlaylayer.bitwidth) + xi2 < (the_map.overlaylayer.height << the_map.overlaylayer.bitwidth) );

	f = 0;
	idx = (yi1 << the_map.overlaylayer.bitwidth) + xi1;
	l = the_map.overlaylayer.width - ( xi2 - xi1 + 1 );
	// re-order or insert relevant feet
	for( j = yi1; j <= yi2; j++ )
	{
		for( i = xi1; i <= xi2; i++ )
		{
			if( (pAnim->feet[f].index >= 0) && (pAnim->feet[f].index == idx) )
				ReorderOverlayLayerDisplayList( pAnim->feet[f].dnode, the_map.overlaylayer.cells + idx );
			else
			{
				if( pAnim->feet[f].index >= 0 )
					RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.overlaylayer.cells + pAnim->feet[f].index );
				pAnim->feet[f].index = idx;
				InsertAnimInOverlayLayerCell( pAnim->feet[f].dnode, the_map.overlaylayer.cells + idx );
			}
			f++;
			idx++;
		}
		idx += l;
	}
	// clear remaining feet
	while( f < pAnim->num_feet )
	{
		if( pAnim->feet[f].index >= 0 )
			RemoveFromDisplayList( pAnim->feet[f].dnode, the_map.overlaylayer.cells + pAnim->feet[f].index );
		else
			break;
		pAnim->feet[f].index = -1;
		f++;
	}
	
	RECT rc;
	rc.left = pAnim->wrect.left;
	rc.top = pAnim->wrect.top;
	rc.right = pAnim->wrect.right;
	rc.bottom = pAnim->wrect.bottom;
	//	InsertRectInUpdateList( rc );
}	//	MoveObjectInOverlaylayer
*/


#define TOP_OBJECTS 4
#define BOTTOM_OBJECTS (NUM_OBJECT_TYPES-TOP_OBJECTS)

void
DisplayLayerInBox(int which, SBOX *pBox)	{
	SHORT	tile;
	RECT	rcTile;
	HRESULT	ddrval;
	DWORD	blt_flags;
	Layer	*pLayer;
	SBOX	intersect;
	LONG	layer_width,
			base_index,
			index,
			xb,
			yb,
			xe,
			ye,
			tilex,
			tiley,
			x,
			y;		

	blt_flags = DDBLTFAST_WAIT;
	if (which > 0)
		blt_flags |= DDBLTFAST_SRCCOLORKEY;

	pLayer = &the_map.layers[which];

	layer_width = pLayer->box.cx;

	if (BoxIntersect(pBox, &pLayer->box, &intersect))	{

		xb = intersect.x;
		xe = intersect.x + intersect.cx;

		yb = intersect.y;
		ye = intersect.y + intersect.cy;

		y = ((yb - the_map.TileBox.y) << 4);
		base_index = (yb - pLayer->box.y)*layer_width - pLayer->box.x + xb;
		for (tiley=yb; tiley<ye; tiley++)	{
			x = ((xb - the_map.TileBox.x) << 4);
			index = base_index;
			for (tilex=xb; tilex<xe; tilex++)	{
				tile = pLayer->tile_array[index++];
				if (tile != NO_TILE)	{
					rcTile.left = (tile & 0xF) << 4;
					rcTile.right = rcTile.left + 16;
					rcTile.top = tile & 0xFFF0;
					rcTile.bottom = rcTile.top + 16;

					ddrval = pTileBuffer->BltFast( x, y, the_tiles.tile_data, &rcTile, blt_flags);
					if (ddrval != DD_OK)
						TRACE("Couldn't BltFast Map Layer %d (%d, %d): %s.\n", which, tilex, tiley, DDErrorToString(ddrval));
				}
				x += 16;
			}
			base_index += layer_width;
			y+=16;
		}
	}
}




void
MoveMap(void)	{
	long	diffx,
			diffy,
			x,y;
	RECT rc;
	HRESULT	ddrval;
	SBOX	box1, box2;

	diffx = the_map.TileBox.x - the_map.OldTilePoint.x;
	if (diffx >= 0)	{
		box1.x = the_map.TileBox.x + the_map.TileBox.cx - diffx;
		box1.cx = diffx;
		box1.y = the_map.TileBox.y;
		box1.cy = the_map.TileBox.cy;

		diffx <<= 4;
		rc.left = diffx;
		rc.right = rcGameSurface.right + 16;
		x = 0;
	}
	else	{
		box1.x = the_map.TileBox.x;
		box1.cx = -diffx;
		box1.y = the_map.TileBox.y;
		box1.cy = the_map.TileBox.cy;

		diffx <<= 4;
		rc.left = 0;
		rc.right = rcGameSurface.right + 16 + diffx;
		x = -diffx;
	}

	diffy = the_map.TileBox.y - the_map.OldTilePoint.y; 
	if (diffy >= 0)	{
		box2.y = the_map.TileBox.y + the_map.TileBox.cy - diffy;
		box2.cy = diffy;
		box2.x = the_map.TileBox.x;
		box2.cx = the_map.TileBox.cx;

		diffy <<= 4;
		rc.top = diffy;
		rc.bottom = rcGameSurface.bottom + 16;
		y = 0;
	}
	else	{
		box2.y = the_map.TileBox.y;
		box2.cy = -diffy;
		box2.x = the_map.TileBox.x;
		box2.cx = the_map.TileBox.cx;

		diffy <<= 4;
		rc.top = 0;
		rc.bottom = rcGameSurface.bottom + 16 + diffy;
		y = -diffy;
	}

	ddrval = pTileBuffer->BltFast( x, y, pTileBuffer, &rc, DDBLTFAST_WAIT);
	if (ddrval != DD_OK)	{
		if (ddrval == DDERR_INVALIDRECT)
			TRACE("Couldn't BltFast TileBuffer to itself (Rect %d %d %d %d): %s.\n", rc.left, rc.top, rc.right, rc.bottom, DDErrorToString(ddrval));
		else
			TRACE("Couldn't BltFast TileBuffer to itself: %s.\n", DDErrorToString(ddrval));
	}

#ifndef FINAL
	if (displaydebug)	{
		ddrval = pDebugBuffer->BltFast( x, y, pDebugBuffer, &rc, DDBLTFAST_WAIT);
		if (ddrval != DD_OK)	{
			if (ddrval == DDERR_INVALIDRECT)
				TRACE("Couldn't BltFast DebugBuffer to itself (Rect %d %d %d %d): %s.\n", rc.left, rc.top, rc.right, rc.bottom, DDErrorToString(ddrval));
			else
				TRACE("Couldn't BltFast DebugBuffer to itself: %s.\n", DDErrorToString(ddrval));
		}
	}
#endif

	for (int i=0; i<the_map.num_layers; i++)	{
		if (diffx)
			DisplayLayerInBox(i, &box1);
		if (diffy)
			DisplayLayerInBox(i, &box2);
	}

#ifndef FINAL
	if (diffx)
		DisplayDebugInBox(&box1);
	if (diffy)
		DisplayDebugInBox(&box2);
#endif

/*
	if (diffx)
		DisplayFogInBox(&box1);
	if (diffy)
		DisplayFogInBox(&box2);

	UpdateFogInBox(&the_map.TileBox);
*/

}




void
DisplayMap()	{
	RECT	rcTile;
	HRESULT	ddrval;


	UpdateCycleTiles();

	if (the_map.redraw)	
	{
		if (the_map.redraw == REDRAW_FULL)	
		{
			for (int i=0; i<the_map.num_layers; i++)	
			{
				DisplayLayerInBox(i, &the_map.TileBox);
			}
#ifndef FINAL
			DisplayDebugInBox(&the_map.TileBox);
#endif
//			DisplayFogInBox(&the_map.TileBox);
		}
		else	
		{
			MoveMap();
			RedrawNonStaticTiles(&the_map.TileBox);
		}
		the_map.redraw = REDRAW_FALSE;
	}
	else
		RedrawNonStaticTiles(&the_map.TileBox);

	rcTile.left = the_map.PixelBox.x & 0xF;
	rcTile.top = the_map.PixelBox.y & 0xF;
	rcTile.right = rcGameSurface.right + rcTile.left;
	rcTile.bottom = rcGameSurface.bottom + rcTile.top;

	// blt tiles to BackBuffer
	ddrval = pBackBuffer->BltFast( 0, 0, pTileBuffer, &rcTile, DDBLTFAST_WAIT);
	if ( ddrval != DD_OK )
		TRACE("Couldn't BltFast TileBuffer to BackBuffer: %s.\n", DDErrorToString(ddrval));
	
#ifndef FINAL
	if (displaydebug)	{
		ddrval = pBackBuffer->BltFast( 0, 0, pDebugBuffer, &rcTile, DDBLTFAST_WAIT | DDBLTFAST_SRCCOLORKEY);
		if (ddrval != DD_OK)
			TRACE("Couldn't BltFast DebugBuffer to BackBuffer: %s.\n", DDErrorToString(ddrval));
	}
#endif

}


///========================================================================
//	Tile cycling structures
///========================================================================
#define	MAX_CYCLE_SIZE	6

struct TileSequence {
	int sequence_size;
	int cur_timer;
	int cycle_speed;
	int frequency;
	int sequence[MAX_CYCLE_SIZE];
};


///========================================================================
//	Tile cycling variables
///========================================================================

#define MAX_CYCLERS		6

int	NumTileCycles = 0;
int FreeTile = 0;
TileSequence *TileCyclers[MAX_CYCLERS];
BOOL CycledThisFrame = FALSE;


///========================================================================
//	Tile cycling initialization
//	This is currently set to setup default cyclers
//  Needs to be changed to load cycling information from level
///========================================================================
void InitTileCycler( void )
{
	for ( int i = 0; i < MAX_CYCLERS; i++ )
		TileCyclers[i] = NULL;
	NumTileCycles = 0;
/*
	FreeTile = 935;
	NumTileCycles = 2;
	TileCyclers[0] = (TileSequence *)malloc(sizeof(TileSequence));
	TileCyclers[0]->sequence_size = 5;
	TileCyclers[0]->cur_timer = 1;
	TileCyclers[0]->cycle_speed = 15;
	TileCyclers[0]->frequency = 1000;
	TileCyclers[0]->sequence[0] = 929;
	TileCyclers[0]->sequence[1] = 931;
	TileCyclers[0]->sequence[2] = 933;
	TileCyclers[0]->sequence[3] = 938;
	TileCyclers[0]->sequence[4] = 936;
	TileCyclers[1] = (TileSequence *)malloc(sizeof(TileSequence));
	TileCyclers[1]->sequence_size = 5;
	TileCyclers[1]->cur_timer = 1;
	TileCyclers[1]->cycle_speed = 15;
	TileCyclers[1]->frequency = 1000;
	TileCyclers[1]->sequence[0] = 930;
	TileCyclers[1]->sequence[1] = 932;
	TileCyclers[1]->sequence[2] = 934;
	TileCyclers[1]->sequence[3] = 939;
	TileCyclers[1]->sequence[4] = 937;
*/
}


///========================================================================
//	Destroy tile cycling stuff
///========================================================================
void FreeTileCycler( void )
{
	for (int i = 0; i < NumTileCycles; i++ )
	{
		if ( TileCyclers[i] != NULL )
			free ( TileCyclers[i] );
		TileCyclers[i] = NULL;
	}
	NumTileCycles = 0;
}


///========================================================================
//	Function:		MoveTile(int dest, int src)
//
//	Description:
//		moves tile from src to dest in the tile set
//
//	Input:			a, b
//
//	Ouput:			none
//
///========================================================================
void MoveTile( int dest, int src )
{
	RECT rc;
	WORD i, j;

	if ( dest == src )
		return;

	i = ( dest & 0xF ) << 4;
	j = ( dest & 0xFFF0 );
	rc.left = ( src & 0xF ) << 4;
	rc.right = rc.left + 16;
	rc.top = src & 0xFFF0;
	rc.bottom = rc.top + 16;

	((LPDIRECTDRAWSURFACE)the_tiles.tile_data)->BltFast( i, j, the_tiles.tile_data, &rc, DDBLTFAST_WAIT );
}


///========================================================================
//	Function:		CycleTiles( int sequence )
//
//	Description:
//		Cycles the tiles in a given sequence
//
//	Input:			sequence
//
//	Ouput:			none
//
///========================================================================
void CycleTiles( int sequence )
{
	ASSERT( sequence >= 0 && sequence < NumTileCycles );
	int  size;

	size = TileCyclers[sequence]->sequence_size;
	if( size <= 1 )
		return;

	MoveTile( FreeTile, TileCyclers[sequence]->sequence[size-1] );
	for (int i = size-2; i >= 0; i-- )
		MoveTile( TileCyclers[sequence]->sequence[i+1], TileCyclers[sequence]->sequence[i] );
	MoveTile( TileCyclers[sequence]->sequence[0], FreeTile );
	CycledThisFrame = TRUE;
}


///========================================================================
//	Function:		UpdateCycleTiles( void )
//
//	Description:
//		Cycles all sequences
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================
void UpdateCycleTiles( void )
{
	if ( !OptionFlag_AnimatedTiles)
		return;
	CycledThisFrame = FALSE;
	for (int i = 0; i < NumTileCycles; i++ )
	{
		if( TileCyclers[i]->cur_timer > 0 )
		{
			TileCyclers[i]->cur_timer--;
			if( TileCyclers[i]->cur_timer == 0 )
				CycleTiles( i );

		}
		if( TileCyclers[i]->cur_timer <= 0 )
		{
			if( rand()%1000 < TileCyclers[i]->frequency )
				TileCyclers[i]->cur_timer = TileCyclers[i]->cycle_speed;
		}
	}
}


///========================================================================
//	Function:		RedrawNonStaticTiles( SBOX * pBox )
//
//	Description:
//		Redraws tiles in tile buffer which might have been cycled
//
//	Input:			box in which tiles are to be updated
//
//	Ouput:			none
//
///========================================================================
void RedrawNonStaticTiles( SBOX * pBox )
{
	SHORT	tile;
	RECT	rcTile;
	HRESULT	ddrval;
	DWORD	blt_flags;
	Layer	*pLayer;
	SBOX	intersect;
	LONG	layer_width,
			base_index,
			index,
			xb,
			yb,
			xe,
			ye,
			tilex,
			tiley,
			x,
			y;
	
	if ( !OptionFlag_AnimatedTiles )
		return;
	if ( !CycledThisFrame )
		return;

	blt_flags = DDBLTFAST_WAIT;
	pLayer = &the_map.layers[0];

	layer_width = pLayer->box.cx;

	if (BoxIntersect(pBox, &pLayer->box, &intersect))	
	{
		xb = intersect.x;
		xe = intersect.x + intersect.cx;
		yb = intersect.y;
		ye = intersect.y + intersect.cy;
		y = ((yb - the_map.TileBox.y) << 4);
		base_index = (yb - pLayer->box.y)*layer_width - pLayer->box.x + xb;

		for ( tiley=yb; tiley<ye; tiley++ )
		{
			x = ( ( xb - the_map.TileBox.x ) << 4 );
			index = base_index;
			for ( tilex=xb; tilex<xe; tilex++ )	
			{
				tile = pLayer->tile_array[index++];
				if ( tile >= 929 && tile <= 939 )
				{					
					rcTile.left = (tile & 0xF) << 4;
					rcTile.right = rcTile.left + 16;
					rcTile.top = tile & 0xFFF0;
					rcTile.bottom = rcTile.top + 16;

					ddrval = pTileBuffer->BltFast( x, y, the_tiles.tile_data, &rcTile, blt_flags);
				}
				x += 16;
			}
			base_index += layer_width;
			y+=16;
		}
	}
}



// FROM UNIT.CPP
// FROM UNIT.CPP
// FROM UNIT.CPP
// FROM UNIT.CPP
// FROM UNIT.CPP
// FROM UNIT.CPP

///========================================================================
//	Function:		UnitUpdateInfluence
//	Description:	update the spheres of influence
///========================================================================

static void	UnitUpdateInfluence( UNIT* pUnit, int flags)
{
	TROOPER*	pTrooper;
    return;
    FOR_EACH_TROOPER(pUnit,pTrooper)
    {
		TrooperUpdateInfluence( pTrooper, flags );
	}
}
    

// FROM trooper.cpp
// FROM trooper.cpp
// FROM trooper.cpp
// FROM trooper.cpp
// FROM trooper.cpp
// FROM trooper.cpp

///========================================================================
//	Function:		TrooperUpdateInfluence
//	Description:	update sphere of influence map for this trooper
///========================================================================

void	TrooperUpdateInfluence( TROOPER* pTrooper, int flags )
{
    return;


    ASSERT( pTrooper );					// validate the parameter

    int 	facing = pTrooper->common.facing;
	int		eArmy = ITEM_ARMY(pTrooper);
	BOOL	bTrooperAdd = FALSE;
	BOOL	bTrooperRemove = FALSE;
    SPOINT 	oldPoint = pTrooper->common.oldPosition;

    if (flags == REMOVE_INFLUENCE){ // take out only
        pTrooper->SOIData = 0;
        bTrooperRemove = TRUE;
    }
    else if (flags == ADD_INFLUENCE){ // add only
        bTrooperAdd = TRUE;
        oldPoint = pTrooper->common.position; // will remove where he is
    }
    else{ // change what needs changing
        // if whole thing has changed tiles, update both
	if ( AiInfluenceTileDiff( &(pTrooper->common.oldPosition), &(pTrooper->common.position) ) )
        {
            bTrooperAdd = bTrooperRemove = TRUE;
        }
        // otherwise its influence remains unchanged
    }
    // if it didnt legally exist on the map, DONT remove anything regardless
    if (pTrooper->common.oldPosition.x == 0) bTrooperRemove = FALSE;
    // if it doesnt legally exist on the map, DONT add anything regardless
    if (pTrooper->common.position.x == 0) bTrooperAdd = FALSE;

    // hasnt been inited yet
    if (!pTrooper->SOIData)
        pTrooper->SOIData = TrooperInfluenceData[ITEM_CLASS(pTrooper)];

    // clear the influence of this object based on the previous position
    if (bTrooperRemove){
        AiApplyInfluence( &(AIInfluenceMap[ eArmy ]),
                          &oldPoint,
                          pTrooper->SOIData,-1);
    }

    // Acquire the new trooper influence data
    if ( bTrooperAdd ){

		// now apply the influence based on the new position
		AiApplyInfluence( &(AIInfluenceMap[ eArmy ]),
                          &(pTrooper->common.position),
                          pTrooper->SOIData, 1);

	}
}


// FROM vehicle.cpp
// FROM vehicle.cpp
// FROM vehicle.cpp
// FROM vehicle.cpp
// FROM vehicle.cpp
// FROM vehicle.cpp


///========================================================================
//	Function:		VehicleUpdateInfluence()
//	Description:	update the sphere of influence map for this vehicle
///========================================================================

void	VehicleUpdateInfluence( VEHICLE* pVehicle, int flags )
{
    ASSERT( pVehicle );					// validate the parameter

    int 	nVehicleDirection = pVehicle->common.facing;
    int 	nTurretDirection = pVehicle->turret_facing;
	int		eArmy = ITEM_ARMY(pVehicle);
	BOOL	bVehicleAdd = FALSE;
	BOOL	bWeaponAdd  = FALSE;
	BOOL	bVehicleRemove = FALSE;
	BOOL	bWeaponRemove  = FALSE;
    SPOINT  oldPoint = pVehicle->common.oldPosition;
    return;
    
    if (flags == REMOVE_INFLUENCE){ // take out only
        bVehicleRemove = TRUE;
        bWeaponRemove  = TRUE;        
        // make sure current location is last location since it is leaving
        oldPoint = pVehicle->common.position;
    }
    else if (flags == ADD_INFLUENCE){ // add only
        pVehicle->lastVehicleFacing = -1;			// trigger reset
		pVehicle->lastWeaponFacing = -1;			// trigger reset
        bVehicleAdd = TRUE;
        bWeaponAdd  = TRUE;
    }
    else{ // change what needs changing
        // if whole thing has changed tiles, update both
        if ( AiInfluenceTileDiff( &(pVehicle->common.oldPosition),
             &(pVehicle->common.position) ) )
        {
            bVehicleAdd = bVehicleRemove = TRUE;
            bWeaponAdd  = bWeaponRemove  = TRUE;
        }

        // otherwise do pieces whose directions change
        else{
            // if facing changed on thing, update it
            if ( nVehicleDirection != pVehicle->lastVehicleFacing )
                bVehicleAdd = bVehicleRemove = TRUE;
            if ( nTurretDirection != pVehicle->lastWeaponFacing ) 
                bWeaponAdd  = bWeaponRemove  = TRUE;
        }
    }
    
    // here are fixes for unusual conditions that shouldnt happen

    // if it didnt legally exist on the map, DONT remove anything regardless
    if (pVehicle->common.oldPosition.x == 0)
        bVehicleRemove = bWeaponRemove = FALSE;
    // if it doesnt legally exist on the map, DONT add anything regardless
    if (pVehicle->common.position.x == 0)
        bVehicleAdd = bWeaponAdd = FALSE;
    // if it doesnt have a weapon, dont update weapon influence
    if (pVehicle->common.weapon.eWeapon == ARMY_NO_WEAPON)
        bWeaponAdd = bWeaponRemove = FALSE;        
 
    // clear the influence of this object based on the previous position
    if (bVehicleRemove){
        AiApplyInfluence( &(AIInfluenceMap[ eArmy ]),
                          &oldPoint,
                          pVehicle->vehicleSOIData,-1);
    }

    // remove turret influence
	if ( bWeaponRemove ) {
        AiApplyInfluence( &(AIInfluenceMap[ eArmy ]),
                          &oldPoint,
                          pVehicle->weaponSOIData,-1);
    }

    // Acquire the new Vehicle influence data
    if ( bVehicleAdd ){
        // if facing changed, switch data
        if ( nVehicleDirection != pVehicle->lastVehicleFacing ){
            int dir = nVehicleDirection >> 4;  // 0..15  CIRCLE_UNITS was 256
            int type = ITEM_CLASS(pVehicle);
            pVehicle->vehicleSOIData = VehicleInfluenceData[type][dir];
            pVehicle->lastVehicleFacing = nVehicleDirection;
        }

		// now apply the influence based on the new position
		AiApplyInfluence( &(AIInfluenceMap[ eArmy ]),
                          &(pVehicle->common.position),
                          pVehicle->vehicleSOIData,1 );
	}

    // Acquire the new turret influence data
    if ( bWeaponAdd ){
        // if facing changed, switch data
        if ( nTurretDirection != pVehicle->lastWeaponFacing){
            int dir = nTurretDirection >> 4;  // 0..15  CIRCLE_UNITS was 256
            int type = pVehicle->common.weapon.eWeapon - ARMY_LARGE_CANNON;
            pVehicle->weaponSOIData = VehicleWeaponInfluenceData[type][dir];
            pVehicle->lastWeaponFacing = nTurretDirection;
        }
            
		// now apply the influence based on the new position
		AiApplyInfluence( &AIInfluenceMap[ eArmy ],
                          &(pVehicle->common.position),
                          pVehicle->weaponSOIData,1 );
	}
}


// FROM ai.cpp
// FROM ai.cpp
// FROM ai.cpp
// FROM ai.cpp
// FROM ai.cpp
// FROM ai.cpp

SOI_MAP		AIMovementMap;			// AI Movement Map
SOI_MAP		AIInfluenceMap[ARMY_LAST_ARMY];	// AI Influence Map

///========================================================================
//	Function:		AiReloadInfluence()
//
//	Description:
//		Reload the base Sphere-Of-Influence map for this world.
//
//	Input:			eArmy	Army whose sphere of influence we need to reload
//
//	Ouput:			none
//
///========================================================================

void	AiReloadInfluence( int eArmy )
{
	TADLINK*	pTads;
	TADLINK*	pWhich;
	int			nNumTads;
	int			nTarget;

	// validate parmeters
	ASSERT( AIInfluenceMap[ eArmy ].map );

	// clear the influence map
	memset( AIInfluenceMap[ eArmy ].map, 0, AIInfluenceMap[ eArmy ].size );

	// based on the army, acquire all units and apply their influence to the map
	switch( eArmy )
	{
	case ARMY_PLAYER:
        pTads = TadGetAttackers( eArmy, &nNumTads );
        break;
	case ARMY_PLAYER_2:
	case ARMY_PLAYER_3:
	case ARMY_PLAYER_4:
	default:
		pTads = TadGetTargets( eArmy, &nNumTads );
    }
    
    if ( pTads )
    {
        // start at the first target and apply each in turn
        pWhich = pTads->pNext; 				// 1st is vehicle??? BW
        for( nTarget=0; nTarget<nNumTads; ++nTarget )
        {
            // make sure we have an active target
            if ( !TadIsFlags( pWhich, TAD_INACTIVE ) )
			{
                // apply its influence
                AiUpdateInfluence( (void*)(pWhich->pTadObject),ADD_INFLUENCE );

				// try the next one
				pWhich = pWhich->pNext;
			}
		}
	}

}

///========================================================================
//	Function:		AiUpdateInfluence()
//
//	Description:
//		Update the Sphere-Of-Influence map for this object, if necessary.
//
//	Input:			pObject		object whose sphere of influence we want
//					bNew		signifies ignore old influence
//
//	Ouput:			none
//
///========================================================================

void	AiUpdateInfluence( void* pObject, int flags )
{
	TAD*	pTadObject;

	// validate parameters
	ASSERT( pObject );

	// now get the TAD object
	pTadObject = (TAD*)pObject;
	if ( !pTadObject ) return;

	// find out which object this is
	switch( pTadObject->eObjType )
	{
	case ARMY_NULL_OBJ:
		// error: null object type
		TRACE( "ERROR: attempting to update influence for a NULL object type (%d). [%s : %d ]\n",
			pTadObject->eObjType, __FILE__, __LINE__ );
		ASSERT(0);
		break;
	case ARMY_UNIT:
	case ARMY_VEHICLE:
	case ARMY_SARGE:
        ASSERT(0); // shouldnt exist now. exists at army creation later
		break;
	case ARMY_ASSET:
//		AssetUpdateInfluence( (OBJECT*)(pTadObject->pAsset), flags );
		TRACE("TBD: AssetUpdateInfluence\n");
		break;
	case ARMY_STRUCTURE:
	case ARMY_OBSTACLE:
		break;
	default:
		// error: illegal object
		TRACE( "ERROR: attempting to update influence for an unknown object type (%d). [%s : %d ]\n",
			pTadObject->eObjType, __FILE__, __LINE__ );
		ASSERT(0);
	}
}

///========================================================================
//	Function:		AiApplyInfluence()
//
//	Description:
//		Apply (or remove) the Sphere-Of-Influence for this object.
//
//	Input:			pPosition		center point (pixels) of sphere of influence
//					pInfluence		sphere of influence data to apply
//
//	Ouput:			none
//
///========================================================================

void	AiApplyInfluence( void* pTheMap, SPOINT* pPosition,
                          unsigned char* pInfluence, int sign )
{
	int		nOffset;
	int		rowM;
	int		colM;
	int		leftoverTop;
	int		leftoverLeft;
	int		leftoverBottom;
	int		leftoverRight;
	int		nLeftBoundary;
	int		nRightBoundary;
	int		nTopBoundary;
	int		nBottomBoundary;
	int		iWidth;
	int		iHeight;
	int		mapWidth;
	int		mapHeight;    
    unsigned char*	pData;
    unsigned char*	pDataBase;
    unsigned char*	pMap;
    unsigned char*	pMapBase;
    int 	n;

	// validate parameters
	ASSERT( pTheMap );
	ASSERT( ((SOI_MAP*)pTheMap)->map );
	ASSERT( pPosition );
	ASSERT( pInfluence );

	// translate the position into a tile
	iWidth       = *++pInfluence;				// width of inf map
	iHeight      = *++pInfluence;				// height of inf map
    mapWidth 	 = ((SOI_MAP*)pTheMap)->width;
    mapHeight 	 = ((SOI_MAP*)pTheMap)->height;
	rowM        = ((pPosition->y) >> 4); 		// tile of center
	colM        = ((pPosition->x) >> 4); 		// tile of center
	leftoverTop       = 0;
	leftoverLeft= 0;
	leftoverBottom       = iHeight;
	leftoverRight       = iWidth;

	// calculate the boundaries of the influence box
	nLeftBoundary = colM - (iWidth>>1);			//tile of left actual map
	nRightBoundary = colM + (iWidth>>1);		//tile of right actual map
	nTopBoundary = rowM - (iHeight>>1);			//tile of top actual map
	nBottomBoundary = rowM + (iHeight>>1);		// tile of bottom actual map
	if ( nLeftBoundary < 0 )					// off left edge?
	{
		leftoverLeft  = -nLeftBoundary;			// residual truncated
		nLeftBoundary = 0;						// new actual left
	}
	if ( nRightBoundary > mapWidth)
	{
		leftoverRight  = nRightBoundary - mapWidth;
		nRightBoundary = mapWidth;
	}
	if ( nTopBoundary < 0 )
	{
		leftoverTop        = -nTopBoundary;
		nTopBoundary = 0;
	}
	if ( nBottomBoundary > mapHeight)
	{
		leftoverBottom = nBottomBoundary - mapHeight;
		nBottomBoundary = mapHeight;
	}

	// now calculate the upper left tile position on map
	nOffset = (nTopBoundary * mapWidth) +  nLeftBoundary;
    pMapBase = pMap = ((SOI_MAP*)pTheMap)->map + nOffset;

	// now calculate the upper left influence position
	nOffset = ((leftoverTop * iWidth) + leftoverLeft);
    pDataBase = pData = ++pInfluence + nOffset;

    if (sign > 0){
        for( rowM=nTopBoundary; rowM<nBottomBoundary; ++rowM )
        {
            for( colM=nLeftBoundary; colM<nRightBoundary; ++colM )
            {
                n = *pData++;
                if (n) 
					*pMap += n; // add influence
                ++pMap;
            }

            // advance to the next row (loops may have been truncated)
            pMapBase  += mapWidth;
            pMap = pMapBase;
            pDataBase += iWidth;
            pData = pDataBase;
        }
    }
    else{
        for( rowM=nTopBoundary; rowM<nBottomBoundary; ++rowM )
        {
            for( colM=nLeftBoundary; colM<nRightBoundary; ++colM )
            {
                n = *pData++;
                if (n) 
					*pMap += -n; // remove influence
                ++pMap;
            }
            // advance to the next row (loops may have been truncated)
            pMapBase  += mapWidth;
            pMap = pMapBase;
            pDataBase += iWidth;
            pData = pDataBase;
        }
    }

}

///========================================================================
//	Function:		AiDrawInfluence()
//
//	Description:
//		draw the influence map values for the current screen.
//
//	Input:			none.
//
//	Ouput:			none.
//
///========================================================================

void	AiDrawInfluence( int eArmy )
{
	COLORREF	fgColor;
	COLORREF	bgColor;
	SPOINT		offset;
	SOI_MAP*	pTheMap;
	int			nTile;
	int			row;
	int			col;
	int			nLeftBoundary;
	int			nRightBoundary;
	int			nTopBoundary;
	int			nBottomBoundary;
	int			width;
	int			height;
	int			nIndex;
	char		nInfluence;

	// acquire the influce map
	pTheMap = &AIInfluenceMap[ eArmy ];

	// use the screen display Tile box to display the influence
	nTile = ((the_map.TileBox.y * the_map.width) + the_map.TileBox.x);

	// calculate the boundaries of the influence box
	width  = the_map.TileBox.cx;
	height = the_map.TileBox.cy;
	nLeftBoundary = the_map.TileBox.x;
	nRightBoundary = nLeftBoundary + the_map.TileBox.cx;
	nTopBoundary = the_map.TileBox.y;
	nBottomBoundary = nTopBoundary + the_map.TileBox.cy;

	// save the current Text Colors
	TextGetColors( &fgColor, &bgColor );
	TextSetColors( RGB_NEAR_BLACK, bgColor );

	pTheMap  = &AIInfluenceMap[ eArmy ];
	offset.x = 4;
	offset.y = 0;
	for( row=nTopBoundary; row<=nBottomBoundary; ++row )
	{
		for( col=nLeftBoundary; col<=nRightBoundary; ++col )
		{
			// access the influence value
			nTile = ((row * the_map.width) + col);
			nInfluence = pTheMap->map[ nTile ];
			if ( nInfluence < 0 )
				nIndex = min( -nInfluence, 15 ) + 16;
			else
				nIndex = min( nInfluence, 15 );

			// write out the influence value
			if ( nInfluence )
			{
				if ( nInfluence < 0 )
					TextSetColors( RGB_WHITE, bgColor );
				else
					TextSetColors( RGB_NEAR_BLACK, bgColor );
				TextWrite( pBackBuffer, offset.x, offset.y, AIhex[ nIndex ], FONT_INFLUENCE, NULL );
			}
			offset.x += 16;
		}
		offset.x  = 4;
		offset.y += 16;
	}

	// restore the current Text Colors
	TextSetColors( fgColor, bgColor );
}

///========================================================================
//	Function:		AiInitInfluence()
//
//	Description:
//		Initialize the Sphere-Of-Influence maps for this world.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void	AiInitInfluence( void )
{
	int	eArmy;

//	FOR_EACH_ARMY(eArmy)
	// requires comm.h
	for( eArmy=ARMY_PLAYER; eArmy<ARMY_LAST_ARMY; ++eArmy )
	{
		// acquire the size of the influence map based on the game map
		AIInfluenceMap[ eArmy ].width  = (USHORT)(the_map.width);
		AIInfluenceMap[ eArmy ].height = (USHORT)(the_map.height);
		AIInfluenceMap[ eArmy ].size   = (AIInfluenceMap[ eArmy ].width *
										  AIInfluenceMap[ eArmy ].height);

		// malloc up the influence map
		AIInfluenceMap[ eArmy ].map = (unsigned char*)malloc( AIInfluenceMap[ eArmy ].size );
		if ( AIInfluenceMap[ eArmy ].map == NULL )
		{
			// report an error
			TRACE("ERROR: Insufficient memory available for AI Influence Map allocation. [%s:%d]\n", 
					  __FILE__, __LINE__ );
			goto exit;
		}

#ifdef MALLOC_DEBUG
		TRACE( "malloc (%ld): AI Influence Map for Army %d\n", AIInfluenceMap[ eArmy ].size, eArmy );
#endif

		// now initialize the influence map
//	 	AiReloadInfluence( eArmy );
	}
exit:
	return;
}

///========================================================================
//	Function:		AiEndInfluence()
//
//	Description:
//		terminate the Sphere-Of-Influence map for this world.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void	AiEndInfluence( void )
{
	int	eArmy;

	// get the world size in tiles
	for( eArmy=ARMY_PLAYER; eArmy<ARMY_LAST_ARMY; ++eArmy )
	{
		// free up the influence map if it exisits
		if ( AIInfluenceMap[ eArmy ].map )
		{
			free( AIInfluenceMap[ eArmy ].map );
			AIInfluenceMap[ eArmy ].map    = NULL;
			AIInfluenceMap[ eArmy ].width  = 0;
			AIInfluenceMap[ eArmy ].height = 0;
			AIInfluenceMap[ eArmy ].size   = 0;

#ifdef MALLOC_DEBUG
		TRACE( "free: Influence Map for Army %d\n", eArmy );
#endif
		}
	}
}

// FROM AI.h
// FROM AI.h
// FROM AI.h
// FROM AI.h
// FROM AI.h
// FROM AI.h

//========================================================================
//				Sphere Of Influenece Structure
//========================================================================
typedef struct
{
	USHORT	width;		// map width in tiles
	USHORT	height;		// map width in tiles
	LONG	size;		// total size of influence map
    unsigned char*	map;// pointer to sphere of influence data
} SOI_MAP;	// Sphere Of Influence Map

extern	SOI_MAP			AIInfluenceMap[];	// AI Influence Map


// FROM soi.h
// FROM soi.h
// FROM soi.h
// FROM soi.h
// FROM soi.h
// FROM soi.h


#ifndef __SOI_H__
#define __SOI_H__


//========================================================================
//				Sphere Of Influenece Maps
//========================================================================

char	Sphere5x5[] =
{
	/*      0 1 2 3 4 */
	/* 0 */ 1,1,1,1,1,
	/* 1 */ 1,2,2,2,1,
	/* 2 */ 1,2,3,2,1,
	/* 3 */ 1,2,2,2,1,
	/* 4 */ 1,1,1,1,1
};

char	Sphere7x7[] =
{
	/*      0 1 2 3 4 5 6 */
	/* 0 */ 1,1,1,1,1,1,1,
	/* 1 */ 1,2,2,2,2,2,1,
	/* 2 */ 1,2,3,3,3,2,1,
	/* 3 */ 1,2,3,4,3,2,1,
	/* 4 */ 1,2,3,3,3,2,1,
	/* 5 */ 1,2,2,2,2,2,1,
	/* 6 */ 1,1,1,1,1,1,1
};

char	Sphere9x9[] =
{
	/*      0 1 2 3 4 5 6 7 8 */
	/* 0 */ 1,1,1,1,1,1,1,1,1,
	/* 1 */ 1,2,2,2,2,2,2,2,1,
	/* 2 */ 1,2,3,3,3,3,3,2,1,
	/* 3 */ 1,2,3,4,4,4,3,2,1,
	/* 4 */ 1,2,3,4,5,4,3,2,1,
	/* 5 */ 1,2,3,4,4,4,3,2,1,
	/* 6 */ 1,2,3,3,3,3,3,2,1,
	/* 7 */ 1,2,2,2,2,2,2,2,1,
	/* 8 */ 1,1,1,1,1,1,1,1,1
};

char	Sphere11x11[] =
{
	/*      0 1 2 3 4 5 6 7 8 9 0 */
	/* 0 */ 1,1,1,1,1,1,1,1,1,1,1,
	/* 1 */ 1,2,2,2,2,2,2,2,2,2,1,
	/* 2 */ 1,2,3,3,3,3,3,3,3,2,1,
	/* 3 */ 1,2,3,4,4,4,4,4,3,2,1,
	/* 4 */ 1,2,3,4,5,5,5,4,3,2,1,
	/* 5 */ 1,2,3,4,5,6,5,4,3,2,1,
	/* 6 */ 1,2,3,4,5,5,5,4,3,2,1,
	/* 7 */ 1,2,3,4,4,4,4,4,3,2,1,
	/* 8 */ 1,2,3,3,3,3,3,3,3,2,1,
	/* 9 */ 1,2,2,2,2,2,2,2,1,2,1,
	/* 0 */ 1,1,1,1,1,1,1,1,1,1,1
};

char	Sphere13x13[] =
{
	/*      0 1 2 3 4 5 6 7 8 9 0 1 2 */
	/* 0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,
	/* 1 */ 1,2,2,2,2,2,2,2,2,2,2,2,1,
	/* 2 */ 1,2,3,3,3,3,3,3,3,3,3,2,1,
	/* 3 */ 1,2,3,4,4,4,4,4,4,4,3,2,1,
	/* 4 */ 1,2,3,4,5,5,5,5,5,4,3,2,1,
	/* 5 */ 1,2,3,4,5,6,6,6,5,4,3,2,1,
	/* 6 */ 1,2,3,4,5,6,7,6,5,4,3,2,1,
	/* 7 */ 1,2,3,4,5,6,6,6,5,4,3,2,1,
	/* 8 */ 1,2,3,4,5,5,5,5,5,4,3,2,1,
	/* 9 */ 1,2,3,4,4,4,4,4,4,4,3,2,1,
	/* 0 */ 1,2,3,3,3,3,3,3,3,3,3,2,1,
	/* 1 */ 1,2,2,2,2,2,2,2,2,2,2,2,1,
	/* 2 */ 1,1,1,1,1,1,1,1,1,1,1,1,1
};

char	Sphere15x15[] =
{
	/*      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 */
	/* 0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	/* 1 */ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
	/* 2 */ 1,2,3,3,3,3,3,3,3,3,3,3,3,2,1,
	/* 3 */ 1,2,3,4,4,4,4,4,4,4,4,4,3,2,1,
	/* 4 */ 1,2,3,4,5,5,5,5,5,5,5,4,3,2,1,
	/* 5 */ 1,2,3,4,5,6,6,6,6,6,5,4,3,2,1,
	/* 6 */ 1,2,3,4,5,6,7,7,7,6,5,4,3,2,1,
	/* 7 */ 1,2,3,4,5,6,7,8,7,6,5,4,3,2,1,
	/* 8 */ 1,2,3,4,5,6,7,7,7,6,5,4,3,2,1,
	/* 9 */ 1,2,3,4,5,6,6,6,6,6,5,4,3,2,1,
	/* 0 */ 1,2,3,4,5,5,5,5,5,5,5,4,3,2,1,
	/* 1 */ 1,2,3,4,4,4,4,4,4,4,4,4,3,2,1,
	/* 2 */ 1,2,3,3,3,3,3,3,3,3,3,3,3,2,1,
	/* 3 */ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
	/* 4 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

char	Sphere17x17[] =
{
/*      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 */

/* 0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
/* 1 */ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
/* 2 */ 1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,
/* 2 */ 1,2,3,4,4,4,4,4,4,4,4,4,4,4,3,2,1,
/* 4 */ 1,2,3,4,5,5,5,5,5,5,5,5,5,4,3,2,1,
/* 5 */ 1,2,3,4,5,6,6,6,6,6,6,6,5,4,3,2,1,
/* 6 */ 1,2,3,4,5,6,7,7,7,7,7,6,5,4,3,2,1,
/* 7 */ 1,2,3,4,5,6,7,8,8,8,7,6,5,4,3,2,1,
/* 8 */ 1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,
/* 9 */ 1,2,3,4,5,6,7,8,8,8,7,6,5,4,3,2,1,
/* 0 */ 1,2,3,4,5,6,7,7,7,7,7,6,5,4,3,2,1,
/* 1 */ 1,2,3,4,5,6,6,6,6,6,6,6,5,4,3,2,1,
/* 2 */ 1,2,3,4,5,5,5,5,5,5,5,5,5,4,3,2,1,
/* 3 */ 1,2,3,4,4,4,4,4,4,4,4,4,4,4,3,2,1,
/* 4 */ 1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,
/* 5 */ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
/* 6 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};


//========================================================================
//				UNIT Spheres Of Influenece
//========================================================================

SOI	LI_SphereOfInfluence =
{
	7,7,						// 7 x 7
	Sphere7x7
};

SOI	HI_SphereOfInfluence =
{
	9,9,						// 9 x 9
	Sphere9x9
};
SOI	CMDO_SphereOfInfluence =
{
	11,11,						// 11 x 11
	Sphere11x11
};
SOI	ENGR_SphereOfInfluence =
{
	5,5,						// 5 x 5
	Sphere5x5
};
SOI	ART_SphereOfInfluence =
{
	11,11,						// 11 x 11
	Sphere11x11
};

SOI*	UNIT_SpheresOfInfluence[ARMY_LAST_UNIT] =
{
	&LI_SphereOfInfluence,
	&HI_SphereOfInfluence,
	&CMDO_SphereOfInfluence,
	&ENGR_SphereOfInfluence,
	&ART_SphereOfInfluence
};


//========================================================================
//				VEHICLE Spheres Of Influenece
//========================================================================

SOI	JEEP_SphereOfInfluence =
{
	9,9,						// 9 x 9
	Sphere9x9
};

SOI	TANK_SphereOfInfluence =
{
	13,13,						// 13 x 13
	Sphere13x13
};

SOI	CHEL_SphereOfInfluence =
{
	13,13,						// 13 x 13
	Sphere13x13
};

SOI	AHEL_SphereOfInfluence =
{
	15,15,						// 15 x 15
	Sphere15x15
};

SOI	HFTR_SphereOfInfluence =
{
	11,11,						// 11 x 11
	Sphere11x11
};

SOI	BOAT_SphereOfInfluence =
{
	9,9,						// 9 x 9
	Sphere9x9
};

SOI	SS_SphereOfInfluence =
{
	11,11,						// 11 x 11
	Sphere11x11
};

SOI*	VEHICLE_SpheresOfInfluence[ARMY_LAST_VEHICLE] =
{
	&JEEP_SphereOfInfluence,
	&TANK_SphereOfInfluence,
	&CHEL_SphereOfInfluence,
	&AHEL_SphereOfInfluence,
	&HFTR_SphereOfInfluence,
	&BOAT_SphereOfInfluence,
	&SS_SphereOfInfluence,
};


//========================================================================
//				STRUCTURE Spheres Of Influenece
//========================================================================


// FROM vehicle.dat
// FROM vehicle.dat
// FROM vehicle.dat
// FROM vehicle.dat
// FROM vehicle.dat
// FROM vehicle.dat


///========================================================================
//							Vehicle Zone Of Control Data
///========================================================================
//Vehicle driving no gun  000 
// Number Patterns 3   Pattern Width 13   Pattern Height 17
unsigned char VehicleInfluence000[ ] =
{
		3,13,17,

	00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,00,00,
	00,00,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,00,15,15,15,15,00,00,
	00,00,15,15,15,15,15,15,15,15,15,00,00,
	00,00,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun  045 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence045[ ] =
{
		3,17,17,

00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
00,00,00,00,00,00,15,15,00,00,00,00,00,00,00,00,00,
00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,
00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
00,00,15,15,15,15,15,15,00,15,15,15,15,15,00,00,00,
00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,
00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,
00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,00,00,
00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
		};

///------------------------------------------------------------------------
//Vehicle driving no gun  090 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence090[ ] =
{
		3,17,17,

	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,00,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun  135 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence135[ ] =
{
		3,17,17,

	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,00,15,15,15,15,15,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun 180 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence180[ ] =
{
		3,17,17,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,00,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun  225 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence225[ ] =
{
		3,17,17,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,00,15,15,15,15,15,15,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun  270 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence270[ ] =
{
	3,17,17,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,00,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Vehicle driving no gun  315 
// Number Patterns 3   Pattern Width 17   Pattern Height 17
unsigned char VehicleInfluence315[ ] =
{
		3,17,17,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,15,15,15,15,15,00,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Tank Cannon 000
// Number Patterns 3   Pattern Width 23   Pattern Height 23
unsigned char TankCannonInfluence000[ ] =
{
		3,23,33,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------
//Tank Cannon 045
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char TankCannonInfluence045[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Tank Cannon 090
// Number Patterns 3   Pattern Width 33   Pattern Height 23
unsigned char TankCannonInfluence090[ ] =
{
		3,33,23,

	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
};

///------------------------------------------------------------------------
//Tank Cannon 135
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char TankCannonInfluence135[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Tank Cannon 180
// Number Patterns 3   Pattern Width 23   Pattern Height 33
unsigned char TankCannonInfluence180[ ] =
{
		3,23,33,

	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00
};

///------------------------------------------------------------------------
//Tank Cannon 225
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char TankCannonInfluence225[ ] =
{
		3,33,33,

	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Tank Cannon 270
// Number Patterns 3   Pattern Width 33   Pattern Height 1239
unsigned char TankCannonInfluence270[ ] =
{
		3,33,23,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,
};

///------------------------------------------------------------------------
//Tank Cannon 315
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char TankCannonInfluence315[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
		};


///------------------------------------------------------------------------
//Heavy Machine Gun 000
// Number Patterns 3   Pattern Width 23   Pattern Height 33
unsigned char HeavyMachineGunInfluence000[ ] =
{
		3,23,33,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------
//Heavy Machine Gun 045
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char HeavyMachineGunInfluence045[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Heavy Machine Gun 090
// Number Patterns 3   Pattern Width 33   Pattern Height 23
unsigned char HeavyMachineGunInfluence090[ ] =
{
		3,33,23,
	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
};

///------------------------------------------------------------------------
//Heavy Machine Gun 135
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char HeavyMachineGunInfluence135[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Heavy Machine Gun 180
// Number Patterns 3   Pattern Width 23   Pattern Height 33
unsigned char HeavyMachineGunInfluence180[ ] =
{
		3,23,33,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00
};

///------------------------------------------------------------------------
//Heavy Machine Gun 225
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char HeavyMachineGunInfluence225[ ] =
{
		3,33,33,

	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Heavy Machine Gun 270
// Number Patterns 3   Pattern Width 33   Pattern Height 23
unsigned char HeavyMachineGunInfluence270[ ] =
{
		3,33,23,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,
};

///------------------------------------------------------------------------
//Heavy Machine Gun 315
// Number Patterns 3   Pattern Width 33   Pattern Height 33
unsigned char HeavyMachineGunInfluence315[ ] =
{
		3,33,33,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 000
// Number Patterns 3   Pattern Width 21   Pattern Height 31
unsigned char MediumMachineGunInfluence000[ ] =
{
		3,21,31,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------
//Medium Machine Gun 045
// Number Patterns 3   Pattern Width 31   Pattern Height 31
unsigned char MediumMachineGunInfluence045[ ] =
{
		3,31,31,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
		};

///------------------------------------------------------------------------
//Medium Machine Gun 090
// Number Patterns 3   Pattern Width 31   Pattern Height 21
unsigned char MediumMachineGunInfluence090[ ] =
{
		3,31,21,
	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 135
// Number Patterns 3   Pattern Width 31   Pattern Height 31
unsigned char MediumMachineGunInfluence135[ ] =
{
		3,31,31,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 180
// Number Patterns 3   Pattern Width 21   Pattern Height 31
unsigned char MediumMachineGunInfluence180[ ] =
{
		3,21,31,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,15,15,15,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 225
// Number Patterns 3   Pattern Width 31   Pattern Height 31
unsigned char MediumMachineGunInfluence225[ ] =
{
		3,31,31,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00, 
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 270
// Number Patterns 3   Pattern Width 31   Pattern Height 21
unsigned char MediumMachineGunInfluence270[ ] =
{
		3,31,21,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,00,00,00,00
};

///------------------------------------------------------------------------
//Medium Machine Gun 315
// Number Patterns 3   Pattern Width 31   Pattern Height 31
unsigned char MediumMachineGunInfluence315[ ] =
{
		3,31,31,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00, 
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------

unsigned char*	VehicleInfluenceData[ ARMY_LAST_VEHICLE ][ 16 ] =
{
	{		// ARMY_NO_VEHICLE
		NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
		NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
	},
	{		// ARMY_JEEP
		VehicleInfluence000,VehicleInfluence045,VehicleInfluence045,VehicleInfluence090,
		VehicleInfluence090,VehicleInfluence135,VehicleInfluence135,VehicleInfluence180,
		VehicleInfluence180,VehicleInfluence225,VehicleInfluence225,VehicleInfluence270,
		VehicleInfluence270,VehicleInfluence315,VehicleInfluence315,VehicleInfluence000
	},
	{		// ARMY_TANK
		VehicleInfluence000,VehicleInfluence045,VehicleInfluence045,VehicleInfluence090,
		VehicleInfluence090,VehicleInfluence135,VehicleInfluence135,VehicleInfluence180,
		VehicleInfluence180,VehicleInfluence225,VehicleInfluence225,VehicleInfluence270,
		VehicleInfluence270,VehicleInfluence315,VehicleInfluence315,VehicleInfluence000
	},
	{		// ARMY_HALFTRACK
		VehicleInfluence000,VehicleInfluence045,VehicleInfluence045,VehicleInfluence090,
		VehicleInfluence090,VehicleInfluence135,VehicleInfluence135,VehicleInfluence180,
		VehicleInfluence180,VehicleInfluence225,VehicleInfluence225,VehicleInfluence270,
		VehicleInfluence270,VehicleInfluence315,VehicleInfluence315,VehicleInfluence000
	},
	{		// ARMY_BOAT
		VehicleInfluence000,VehicleInfluence045,VehicleInfluence045,VehicleInfluence090,
		VehicleInfluence090,VehicleInfluence135,VehicleInfluence135,VehicleInfluence180,
		VehicleInfluence180,VehicleInfluence225,VehicleInfluence225,VehicleInfluence270,
		VehicleInfluence270,VehicleInfluence315,VehicleInfluence315,VehicleInfluence000
	},
	{		// ARMY_COMMANDER
		VehicleInfluence000,VehicleInfluence045,VehicleInfluence045,VehicleInfluence090,
		VehicleInfluence090,VehicleInfluence135,VehicleInfluence135,VehicleInfluence180,
		VehicleInfluence180,VehicleInfluence225,VehicleInfluence225,VehicleInfluence270,
		VehicleInfluence270,VehicleInfluence315,VehicleInfluence315,VehicleInfluence000
	}
};

unsigned char*	VehicleWeaponInfluenceData[ 3 ][ 16 ] =
{
	{		// TANK LARGE CANNON
		TankCannonInfluence000,TankCannonInfluence045,TankCannonInfluence045,TankCannonInfluence090,
		TankCannonInfluence090,TankCannonInfluence135,TankCannonInfluence135,TankCannonInfluence180,
		TankCannonInfluence180,TankCannonInfluence225,VehicleInfluence225,TankCannonInfluence270,
		TankCannonInfluence270,TankCannonInfluence315,TankCannonInfluence315,TankCannonInfluence000
	},
	{		// JEEP MEDIUM MACHINE GUN
		MediumMachineGunInfluence000,MediumMachineGunInfluence045,MediumMachineGunInfluence045,
		MediumMachineGunInfluence090,MediumMachineGunInfluence090,MediumMachineGunInfluence135,
		MediumMachineGunInfluence135,MediumMachineGunInfluence180,MediumMachineGunInfluence180,
		MediumMachineGunInfluence225,MediumMachineGunInfluence225,MediumMachineGunInfluence270,
		MediumMachineGunInfluence270,MediumMachineGunInfluence315,MediumMachineGunInfluence315,
		MediumMachineGunInfluence000
	},
	{		// HALFTRACK HEAVY MACHINE GUN
		HeavyMachineGunInfluence000,HeavyMachineGunInfluence045,HeavyMachineGunInfluence045,
		HeavyMachineGunInfluence090,HeavyMachineGunInfluence090,HeavyMachineGunInfluence135,
		HeavyMachineGunInfluence135,HeavyMachineGunInfluence180,HeavyMachineGunInfluence180,
		HeavyMachineGunInfluence225,HeavyMachineGunInfluence225,HeavyMachineGunInfluence270,
		HeavyMachineGunInfluence270,HeavyMachineGunInfluence315,HeavyMachineGunInfluence315,
		HeavyMachineGunInfluence000
	}
};

  

// excised portion of GetVehicleInput
void	GetVehicleInput(VEHICLE *pVehicle)
{		/*
		if (sargestop) //stops moving when you stop pressing the key
		{
				//emulate joystick with keyboard

			if (action & DO_EXTRASPEED)
				joyradius=701;
			else 
				joyradius=401;

			if (action & DO_ACCELERATE)
				joydata.y=-joyradius;

			if (action & DO_DECELERATE)
				joydata.y=joyradius;

			if (action & DO_TURN_RIGHT)
				joydata.x=joyradius;

			if (action & DO_TURN_LEFT)
				joydata.x=-joyradius;

			if (action & DO_FIRE)
				joydata.buttonpressed[0]=1;
		}
		else
		{
			if (action & (DO_ACCELERATE|DO_DECELERATE|DO_TURN_RIGHT|DO_TURN_LEFT))
			{
				
				if (curspeed==0)
					curspeed=1;

				if (action & DO_EXTRASPEED)
					curspeed=2;

				if (action & DO_ACCELERATE)
				{
					if (action & DO_TURN_RIGHT)
						curdirection=7;
					else if (action & DO_TURN_LEFT)
						curdirection=1;
					else
						curdirection=0;
				}
				else if (action & DO_DECELERATE)
				{
					if (action & DO_TURN_RIGHT)
						curdirection=5;
					else if (action & DO_TURN_LEFT)
						curdirection=3;
					else
						curdirection=4;
				}
				else if (action & DO_TURN_RIGHT)
					curdirection=6;
				else
					curdirection=2;
			}

			if (action & DO_STOP)
			{
				action ^= DO_STOP;
				if (curspeed)
					curspeed--;
			}

			switch(curspeed)
			{
			case 0:
				joydata.x=0;
				joydata.y=0;
				joyradius=0;
				break;

			case 1:
				joyradius=401;
				break;

			case 2:
				joyradius=701;
				break;
			}

			if (joyradius)
				switch(curdirection)
				{
				case 0:
					joydata.x=0;
					joydata.y=-joyradius;
					break;
				case 1:
					joydata.x=-joyradius;
					joydata.y=-joyradius;
					break;
				case 2:
					joydata.x=-joyradius;
					joydata.y=0;
					break;
				case 3:
					joydata.x=-joyradius;
					joydata.y=joyradius;
					break;
				case 4:
					joydata.x=0;
					joydata.y=joyradius;
					break;
				case 5:
					joydata.x=joyradius;
					joydata.y=joyradius;
					break;
				case 6:
					joydata.x=joyradius;
					joydata.y=0;
					break;
				case 7:
					joydata.x=joyradius;
					joydata.y=-joyradius;
					break;
				}

			if (action & DO_FIRE)
				joydata.buttonpressed[0]=1;

		}
		*/



//	if (usejoystick)
	{
		/*
		SPOINT origin={0,0};
		SPOINT target;
		int direction;
		int distancesquared;

		target.x=joydata.x;
		target.y=joydata.y;

		direction=GetDirection(&origin, &target);
		distancesquared=target.x*target.x+target.y*target.y;

		if ((pSarge->pendingAction != AVATAR_FIRE) || 
				((pSarge->pendingAction == AVATAR_FIRE) && (AvatarLastCompleted(AVATAR_FIRE, pSarge->pAvatar))))
		{	
			if (distancesquared>490000)
				SargeSetAvatar(pSarge,AVATAR_RUN);
			else if (distancesquared>160000)
				SargeSetAvatar(pSarge,AVATAR_WALK);
			else if (distancesquared>40000)
				SargeSetAvatar(pSarge,AVATAR_SHUFFLE);
			else 
				SargeSetAvatar(pSarge,AVATAR_STATIONARY);
		}


		if (joydata.buttonpressed[0])
			SargeSetAvatar(pSarge,AVATAR_FIRE);

		if (distancesquared>40000)
			pSarge->pendingDirection=direction;
		*/
	}
}


// FROM aiy.CPP
// FROM aiy.CPP
// FROM aiy.CPP
// FROM aiy.CPP
// FROM aiy.CPP
// FROM aiy.CPP
#define SAME_ARMY(unit,x) ((unit)->common.nUniqueID & x)

void CmdrInitHunt(){// clear for hunting

    IPOINT index;
    WALKGRID(index){
        CLEARBEEN(index);
        CLEARSEEN(index);
    }
}

static int TooClose(int unit,int index,int mindistance){

    int safe = TRUE,uid,d;
    UNIT* pUnit;
    int side = forces[unit]->common.nUniqueID & AI_ID_ARMY_MASK;
    FOR_ALL_UNITS(uid){
        pUnit = forces[uid];
        if (!UNIT_ON_MAP(pUnit)) continue;
        if (forces[uid]->aiState !=  HUNT) continue;
        if (!SAME_ARMY(pUnit,side)) continue;
        if (uid == unit) continue;
        IPOINT loc1 = IPOINT_FROM_EPOINT(forces[uid]->target);
        d = TileDistance(index,loc1);
        // too close to another hunter origin
        if (d <= mindistance) return TRUE;
    }
    return FALSE;
}

int AcceptableHunt(int unit,IPOINT at,IPOINT index,
    IPOINT origin,int maxdistance,int mindistance){

    int d;
    
    if (SEEN(index)) return 0; /* seen here*/
    if (BEEN(index)) return 0; /* been here */
    if (UntrafficableUnit(index)) return 0; /* dont care about here */

    // if target is 0 means finding new hunt origin.
    // find one > min away from all other hunters
    if (forces[unit]->target == 0){
           if (TooClose(unit,index,mindistance)) return 0;
    }
    else{ /* stay withing max dist from origin */
        // new one to go to, seek closest to self
        d = TileDistance(index,origin);
        if (d > maxdistance) return 0;
    }

    // can i get there
    EPOINT waypoints[100+1];
    PlanRoute(0,DOABLE_ONLY,0,1,
        forces[unit]->common.location,EPOINT_FROM_IPOINT(index),waypoints,100);
    if (waypoints[0] == 0){ /* no way to ever get there*/
        BE(index);

		#if defined(_DEBUG)
        if (mapView == 1){
            SetValueInDebugLayer(IPOINT_X(index),IPOINT_Y(index),'$');
        }
		#endif
		
        return 0;
    }       
    return TRUE;
}

static EPOINT CmdrHunt(int unit,EPOINT location,int maxdistance,int mindistance){
     // go to where noone is going

    IPOINT index,at,origin;
    int old = tracerouter,fanoutLimit,x,y,n = 0,atx,aty;
    tracerouter = 0;
    if (maxdistance >= 9999) forces[unit]->target = 0; // find new origin 
    at = forces[unit]->common.tile;
    origin = IPOINT_FROM_EPOINT(location);
    atx = x = IPOINT_X(at);
    aty = y = IPOINT_Y(at);
    if (x < (map_width - x)) x = map_width - x;
    if (y < (map_height - y)) y = map_height - y;
    fanoutLimit = (x >= y) ? x : y;

    // walk in expanding squares from self til find a place to hunt
    while (++n <= fanoutLimit){
        int ylow = aty - n, xlow = atx - n;
        int yhi = aty + n, xhi = atx + n;
        if (OFF_X(xlow)) xlow = 0;
        if (OFF_X(xhi)) xhi = 0;
        if (OFF_Y(ylow)) ylow = 0;
        if (OFF_Y(yhi)) yhi = 0;
        int xlim = atx + n;
        for (x = atx - n; x <= xlim; ++x){
            if (OFF_X(x)) continue;
            if (ylow){
                index = INDEX(x,ylow);
                if (AcceptableHunt(unit,at,index,origin,
                    maxdistance,mindistance)) goto success;
            }
            if (yhi){
                index = INDEX(x,yhi);
                if (AcceptableHunt(unit,at,index,origin,
                    maxdistance,mindistance)) goto success;
            }
        }
        int ylim = aty + n - 1;
        for (y = aty - n + 1; y <= ylim; ++y){
            if (OFF_Y(y)) continue;
            if (xlow){
                index = INDEX(xlow,y);
                if (AcceptableHunt(unit,at,index,origin,
                    maxdistance,mindistance)) goto success;
            }
            if (xhi){
                index = INDEX(xhi,y);
                if (AcceptableHunt(unit,at,index,origin,
                    maxdistance,mindistance)) goto success;
            }
        }
    }
    tracerouter = old;
    return 0;

success:
    tracerouter = old;
    if (mapView == 1 && maxdistance >= 9999){
        SEE(index); /* claim seen here in advance*/

		#if defined(_DEBUG)
        SetValueInDebugLayer(IPOINT_X(index),IPOINT_Y(index),'+');
		#endif

    }                    
	return EPOINT_FROM_IPOINT(index);
}

static void SeePoints(UNIT* pUnit){ /* mark what new things he sees */

    IPOINT index = pUnit->common.tile,at;
    int x,y,ix,iy;
    if (BEEN(index)) return; // already been on this exact spot
    BE(index); // mark walked here

    ix = IPOINT_X(index);
    iy = IPOINT_Y(index);
    for (x = ix-visibilityRange; x <= ix+visibilityRange; ++x){
        if (OFF_X(x)) continue;
        for (y = iy-visibilityRange; y <= iy+visibilityRange; ++y){
            if (OFF_Y(y)) continue;
            at = INDEX(x,y);
            if (SEEN(at)) continue; 
            if (!CanSee(index,at)) continue;	// cant see here
            SEE(at);

			#if defined(_DEBUG)
            if (mapView == 1) SetValueInDebugLayer(x,y,0);
			#endif
        }
    }
}

static void AllUnitsSee(int who){// what do we see

    UNIT* pUnit;
    int unit;
    int eArmy;
    LEGION* pLegion;
    FOR_EACH_LOCAL_ARMY(eArmy)
    { 
      pLegion = ArmyGetLegion(eArmy);
      FOR_EACH_UNIT(pLegion,pUnit)
      {
        if (!UNIT_ON_MAP(pUnit)) continue;
        if (pUnit->aiState != HUNT) continue;
        unit = pUnit->aiUID;
        SeePoints(pUnit);
      }
    }
}

static int EvadeOK(IPOINT index,IPOINT to, IPOINT from,int d,int distance,
    int neard){

    int dx;
    // the point must be farther from him than we are now
    dx = TileDistance(index,to);
    if (dx <= d) return FALSE; // its closer to him
    // the point must be at least x away from him
    if (dx <= distance) return FALSE;
    dx = TileDistance(index,from);
    // the point must be near us
    if (dx > neard) return FALSE;
    return TRUE;
}

static EPOINT RiskyEvade(IPOINT from, IPOINT to, int distance){

    IPOINT index; int d = TileDistance(from,to),myd;
    IPOINT best = 0; int bestd = 0;
	// otherwise consider places that will make us most distance away 
    int xi = IPOINT_X(to),xj = IPOINT_Y(to),x,y;

    // search in rect around foe for a place to go away from him and me
    for (x = xi-distance; x <= xi+distance; ++x){
        if (OFF_X(x)) continue;
        for (y = xj-distance; y <= xj+distance; ++y){
            if (OFF_Y(y)) continue;
            index = INDEX(x,y);            
            if (UntrafficableUnit(index)) continue;

            // I want near to him on other side of him sort of
            if (TileDistance(index,from) < d) continue;
            myd = TileDistance(index,to);
            if (myd <= bestd) continue; // no better

            // can i get there
            EPOINT waypoints[1000+1];
            PlanRoute(0,DOABLE_ONLY,0,1,EPOINT_FROM_IPOINT(from),
                EPOINT_FROM_IPOINT(index),waypoints,1000);
            if (waypoints[0] == 0) continue;

            // store new better
            bestd = myd;
            best = index;
        }
    }
    return EPOINT_FROM_IPOINT(best);
}

// FROM trooper.dat
// FROM trooper.dat
// FROM trooper.dat
// FROM trooper.dat
// FROM trooper.dat
// FROM trooper.dat

///========================================================================
//							Trooper Zone Of Control Data
///========================================================================
// Rifle Man
// Number Patterns 3   Pattern Width 27   Pattern Height 27
unsigned char RifleInfluence[ ] = {
		3,27,27,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------
// Grenade Man
// Number Patterns 3   Pattern Width 19   Pattern Height 19
unsigned char GrenadeInfluence[ ] = {
		3,19,19,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,00,00,00,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,00,00,00,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,00,00,00,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00
};


///------------------------------------------------------------------------
// Flame Man
// Number Patterns 3   Pattern Width 15   Pattern Height 15
unsigned char FlameInfluence[ ] = {
		3,15,15,
	00,00,00,00,00,15,15,15,15,15,00,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,00,15,15,15,15,15,00,00,00,00,00
};


///------------------------------------------------------------------------
//Bazooka Man
// Number Patterns 3   Pattern Width 27   Pattern Height 27
unsigned char BazookaInfluence[ ] = {
		3,27,27,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,00,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00
};


///------------------------------------------------------------------------
//Engineer Man
// Number Patterns 3   Pattern Width 5   Pattern Height 5
unsigned char EngineerInfluence[ ] = {
		3,5,5,
	00,00,00,00,00,
	00,00,15,00,00,
	00,15,15,15,00,
	00,00,15,00,00,
	00,00,00,00,00
};


///------------------------------------------------------------------------
//Miner Man
// Number Patterns 3   Pattern Width 5   Pattern Height 5
unsigned char MinerInfluence[ ] = {
		3,5,5,
	00,00,00,00,00,
	00,00,15,00,00,
	00,15,15,15,00,
	00,00,15,00,00,
	00,00,00,00,00
		};



///------------------------------------------------------------------------
//Mortar Man
// Number Patterns 3   Pattern Width 43   Pattern Height 43

unsigned char MortarInfluence[ ] = {
		3,43,43,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,
	00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,
	00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,
	00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,15,15,15,15,15,15,15,15,15,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
};

unsigned char*	TrooperInfluenceData[ ARMY_LAST_TROOPER ] =
{
	RifleInfluence,			// ARMY_RIFLE_MEN
	GrenadeInfluence,		// ARMY_GRENADE_MEN
	FlameInfluence,			// ARMY_FLAME_MEN
	BazookaInfluence,		// ARMY_BAZOOKA_MEN
	EngineerInfluence,		// ARMY_ENGINEER_MEN
	MortarInfluence,		// ARMY_MORTAR_MEN
	MinerInfluence			// ARMY_MINER_MEN
};

// FROM clock.h
// FROM clock.h
// FROM clock.h
// FROM clock.h
// FROM clock.h
// FROM clock.h

///========================================================================
//							GLOBAL DEFINES
///========================================================================
#define	CLOCK_RATE		1		// 33

#define	CLOCK_MAX_HOUR	23		// 23:xx:xx    11:00pm
#define	CLOCK_MAX_MIN	59		// xx:59:xx
#define	CLOCK_MAX_SEC	59		// xx:xx:59

#define	CLOCK_MIDNIGHT	0
#define CLOCK_NOON		12

///========================================================================
//							GLOBAL DATA TYPES
///========================================================================

typedef enum {
	SUNDAY = 0,	
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,

	// PLACE NOTHING BELOW THIS LINE
	MAX_DAYS
} DAY_OF_WEEK;

typedef struct	{
	short	eDayOfTheWeek;		// SUNDAY...SATURDAY
	short	nHourOfTheDay;		// 0..23 military hour of the day
	short	nMinuteOfTheDay;	// 0..59 minutes in the hours
	short	nSecondsOfTheDay;	// 0..59 seconds in the minute
	UINT	uTimerID;			// interrupt timer ID
} TIME;

///========================================================================
//							GLOBAL VARIABLES
///========================================================================
extern	char*	ClockDayNames[ MAX_DAYS ];

///========================================================================
//							GLOBAL PROTOTYPES
///========================================================================

void			ClockInit( void );
void			ClockExit( void );
void			ClockSet( TIME* pTime );
void			ClockGet( TIME* pTime );
#if 0
void CALLBACK	ClockTick( void );
#else
void			ClockTick( void );
#endif
void			ClockUpdate( TIME* pTime );
BOOL			ClockChange( void );
void			ClockChangeClear( void );

// FROM clock.c
// FROM clock.c
// FROM clock.c
// FROM clock.c
// FROM clock.c
// FROM clock.c
    

// Includes
#include "stdafx.h"

#include "Sprite.h"
#include "Clock.h"

///========================================================================
//							LOCAL DEFINES
///========================================================================

///========================================================================
//							LOCAL VARIABLES
///========================================================================
static	TIME		ClockTime;
static	unsigned	ClockSubTick;
static	BOOL		ClockChgFlag;

char*	ClockDayNames[ MAX_DAYS ] =
{
	"SUN\0", "MON\0", "TUE\0", "WED\0", "THU\0", "FRI\0", "SAT\0"
};

///========================================================================
//							LOCAL PROTOTYPES
///========================================================================

///========================================================================
//	Function:		ClockInit()
//
//	Description:
//		Initialize the clock processing.
//
//	Input:			none
//
//	Ouput:			error			FALSE if successful, TRUE otherwise
//
///========================================================================

void	ClockInit()
{
	// initialize the clock values to SUNDAY 00:00:00
	ClockTime.eDayOfTheWeek    = SUNDAY;// SUNDAY...SATURDAY
	ClockTime.nHourOfTheDay    = 0;		// 0..23 military hour of the day
	ClockTime.nMinuteOfTheDay  = 0;		// 0..59 minutes in the hours
	ClockTime.nSecondsOfTheDay = 0;		// 0..59 seconds in the minute
	ClockChgFlag               = TRUE;	// signifiy that the clock has changed

	// initialize the clock sub tick counter
	ClockSubTick = 0;

#if 0
	// Start a timer event. After the event has been activated, the timer will
	// make a callback to the STRM monitor routine.
	ClockTime.uTimerID = timeSetEvent( CLOCK_RATE, 10, (LPTIMECALLBACK)ClockTick,
									   (DWORD)0, TIME_PERIODIC );
	if (ClockTime.uTimerID == 0)
		TRACE( "ERROR: could not create CLOCK uTimerID\n\n" );
#endif
}

///========================================================================
//	Function:		ClockExit()
//
//	Description:
//		Terminate the clock processor.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void		ClockExit( void )
{
#if 0
		timeKillEvent( ClockTime.uTimerID );
		timeEndPeriod( CLOCK_RATE );
#endif
}

///========================================================================
//	Function:		ClockSet()
//
//	Description:
//		Set the game clock.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void ClockSet( TIME* pTime )
{
	ClockTime.eDayOfTheWeek    = pTime->eDayOfTheWeek;		// SUNDAY...SATURDAY
	ClockTime.nHourOfTheDay    = pTime->nHourOfTheDay;		// 0..23 military hour of the day
	ClockTime.nMinuteOfTheDay  = pTime->nMinuteOfTheDay;	// 0..59 minutes in the hours
	ClockTime.nSecondsOfTheDay = pTime->nSecondsOfTheDay;	// 0..59 seconds in the minute
	ClockChgFlag               = TRUE;	// signifiy that the clock has changed
}

///========================================================================
//	Function:		ClockGet()
//
//	Description:
//		Get the game clock.
//
//	Input:			pTime	pointer to location to store clock time.
//
//	Ouput:			none
//
///========================================================================

void ClockGet( TIME* pTime )
{
	pTime->eDayOfTheWeek       = ClockTime.eDayOfTheWeek;		// SUNDAY...SATURDAY
	pTime->nHourOfTheDay       = ClockTime.nHourOfTheDay;		// 0..23 military hour of the day
	pTime->nMinuteOfTheDay     = ClockTime.nMinuteOfTheDay;		// 0..59 minutes in the hours
	pTime->nSecondsOfTheDay    = ClockTime.nSecondsOfTheDay;	// 0..59 seconds in the minute
}

///========================================================================
//	Function:		ClockTick()
//
//	Description:
//		Add a second to the game clock.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

#if 0
void CALLBACK ClockTick( void )
#else
void		  ClockTick( void )
#endif
{
	// see if we've reached the rate
	if ( ++ClockSubTick < CLOCK_RATE )
		goto exit;		// not yet
	else
		ClockSubTick = 0;	// we've had a tick, update the clock

	// the clock is being updated, signify a change
	ClockChgFlag = TRUE;

	// increment the clock by 1 second
	if ( ++(ClockTime.nSecondsOfTheDay) < 60 )
		goto exit;

	// seconds advanced into minutes, reset seconds
	ClockTime.nSecondsOfTheDay = 0;
	if ( ++(ClockTime.nMinuteOfTheDay) < 60 )
		goto exit;

	// minutes advanced into hours, reset minutes
	ClockTime.nMinuteOfTheDay = 0;
	if ( ++(ClockTime.nHourOfTheDay) < 24 )
		goto exit;

	// hours advanced into days, reset hours
	ClockTime.nHourOfTheDay = 0;
	if ( ++(ClockTime.eDayOfTheWeek) <= SATURDAY )
		goto exit;

	// days advanced into next week, reset days
	ClockTime.nHourOfTheDay = SUNDAY;

exit:
	return;
}

///========================================================================
//	Function:		ClockUpdate()
//
//	Description:
//		Update the clock information.
//
//	Input:			pTime			pointer to CLOCK offsets
//
//	Ouput:			none
//
///========================================================================


void	ClockUpdate( TIME* pTime )
{
	// update the number of seconds, account for roll-over
	ClockTime.nSecondsOfTheDay += pTime->nSecondsOfTheDay;	// 0..59 seconds in the minute
	if ( ClockTime.nSecondsOfTheDay > CLOCK_MAX_SEC )
	{
		ClockTime.nSecondsOfTheDay -= (CLOCK_MAX_SEC+1);
		++(ClockTime.nMinuteOfTheDay);
	}
	if ( ClockTime.nSecondsOfTheDay < 0 )
	{
		ClockTime.nSecondsOfTheDay += CLOCK_MAX_HOUR;
		--(ClockTime.nMinuteOfTheDay);
	}

	// update the number of minutes, account for roll-over
	ClockTime.nMinuteOfTheDay  += pTime->nMinuteOfTheDay;	// 0..59 minutes in the hours
	if ( ClockTime.nMinuteOfTheDay > CLOCK_MAX_HOUR )
	{
		ClockTime.nMinuteOfTheDay -= (CLOCK_MAX_HOUR+1);
		++(ClockTime.nHourOfTheDay);
	}
	if ( ClockTime.nMinuteOfTheDay < 0 )
	{
		ClockTime.nMinuteOfTheDay += CLOCK_MAX_HOUR;
		--(ClockTime.nHourOfTheDay);
	}

	// update the number of hours, account for roll-over
	ClockTime.nHourOfTheDay    += pTime->nHourOfTheDay;		// 0..23 military hour of the day
	if ( ClockTime.nHourOfTheDay > CLOCK_MAX_HOUR )
	{
		ClockTime.nHourOfTheDay -= (CLOCK_MAX_HOUR+1);
		++(ClockTime.nHourOfTheDay);
	}
	if ( ClockTime.nHourOfTheDay < 0 )
	{
		ClockTime.nHourOfTheDay += CLOCK_MAX_HOUR;
		--(ClockTime.nHourOfTheDay);
	}

	ClockTime.eDayOfTheWeek    += pTime->eDayOfTheWeek;		// SUNDAY...SATURDAY
	if ( ClockTime.eDayOfTheWeek > SATURDAY )
		ClockTime.eDayOfTheWeek -= (SATURDAY+1);
	if ( ClockTime.eDayOfTheWeek < SUNDAY )
		ClockTime.eDayOfTheWeek += SATURDAY;
}

///========================================================================
//	Function:		ClockChange()
//
//	Description:
//		return the game clock change flag.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

BOOL	ClockChange( void )
{
	return( ClockChgFlag );
}

///========================================================================
//	Function:		ClockChangeClear()
//
//	Description:
//		Clear the game clock change flag.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void	ClockChangeClear( void )
{
	ClockChgFlag = FALSE;
}

/*
legacy of being able to click on an object an give orders to attack or defend it
		if (curselectedunit) //the right click means give the current unit an order
		{

			SPOINT spt;
			ITEM *pObj;
			UNIT_ORDER curorder;
			
			spt.x=point.x;
			spt.y=point.y;
			ScreenToWorld(&spt);

			pObj=GetSignificantObject(&spt);
			curorder=UNIT_ATTACK;
			if (curorder!=UNIT_NO_ORDER)
			{
				TraceObject((OBJECT *)pObj);

				if (pObj && pObj->pTad)
				{
					UnitOrders(curselectedunit, curorder, OFF_THE_MAP, pObj, (GetKeyState(VK_SHIFT)<0) ? FAST_SPEED : NORMAL_SPEED);
					curtarget.target_type=TARGET_OBJECT;
					curtarget.pObj=pObj;
				}
				else
				{
					UnitOrders(curselectedunit, curorder, spt, NULL, (GetKeyState(VK_SHIFT)<0) ? FAST_SPEED : NORMAL_SPEED);
					curtarget.target_type=TARGET_POINT;
					curtarget.spt=spt;
				}
			}

		}
*/




// wizard thread messages

		case UM_CONNECT_SETUP:
//			DWORD  ThreadId;
//			ghThread = CreateThread(NULL,0,DoWizard,NULL,0,&ThreadId);
			ASSERT(0);	// shouldn't be here
			break;

		case UM_TDG_LAUNCH:
/*
			// cleanup the wizard thread
			if (!gpComm->m_bStartedByLobby && ghThread)
			{
				// wait for thread to exit
				while (!GetExitCodeThread(ghThread, &dwRetCode));
				CloseHandle(ghThread);
			}

			// start the game in rest mode
			if ( !gpComm->m_bHost) {
				gpComm->SetRemote(1);	 // we are joining
//				gpComm->m_ArmyIndex[0] = ARMY_TAN;
//				gpComm->m_ArmyIndex[1] = ARMY_GREEN;
//				gpComm->m_ArmyIndex[2] = ARMY_NO_COLOR;
//				gpComm->m_ArmyIndex[3] = ARMY_NO_COLOR;
			}
			LaunchGame();
			// in MultiPlayer we don't start until host sends start game message
			return TRUE;
*/
			ASSERT(0);	// shouldn't be here
			break;

		case UM_TDG_ABORT:
			ASSERT(0);	// shouldn't be here
			break;
/*
			// cleanup the wizard thread
			// Add code here for SINGLE PLAYER mode
			gpComm->ClearRemote(1);
			if (ghThread)
			{
				// wait for thread to exit
				while (!GetExitCodeThread(ghThread, &dwRetCode));
				CloseHandle(ghThread);
			}
			return TRUE;
*/

		case UM_TDG_CREATEPLAYER:
		//	SendPlayerMsg();
			return TRUE;

// wizard thread messages


				int			OnGameStartDialog();
	int			OnGameOptionsDialog();
	int			OnServiceProviderDialog();
	int			OnGameSetupDialog();
	int			OnHostSessionDialog();
	int			OnJoinSessionDialog();
	int			OnSelectCampaignDialog();
	int			OnMultiPlyrSelectCampaignDialog();
	int			OnJoinArmySelectDialog();
	int			OnMissionSelectDialog();
	int			OnMissionSelect1Dialog();
	int			OnMissionSelect2Dialog();
	int			OnMissionSelect3Dialog();
	int			OnMissionSelect4Dialog();
	int			OnMissionSelectMoreDialog();
	int			OnTitleScreenDialog();

//========================================================================

int CArmyMenApp::OnGameStartDialog() 
{
	int				result  = IDCANCEL;
	BOOL			done    = FALSE;
	CGameStartDlg	gameStartDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	while ( !done )
	{
		result = gameStartDlg.DoModal();
		switch( result )
		{
		case IDC_ONE_PLAYER_BUTTON:
			result = OnSelectCampaignDialog();
			if ( result != ID_BACK )
				done = TRUE;
			break;
		case IDC_MULTI_PLAYER_BUTTON:
			pMainFrame->SetMultiPlayer( gameStartDlg.m_MultiPlayerButton );

			if ( gpComm->IsConnected() == FALSE )
				result = OnServiceProviderDialog();
			else
				result = OnMultiPlyrSelectCampaignDialog();

			if ( result != ID_BACK )
				done = TRUE;
			break;
		case IDC_DISCONNECT_BUTTON:
			gpComm->Disconnect();
			result = IDOK;
			done   = TRUE;
			break;
		case IDC_OPTIONS_BUTTON:
			result = OnGameOptionsDialog();
			done = TRUE;
			break;
		case IDC_QUIT_BUTTON:
			pMainFrame->PostMessage(WM_CLOSE, 0, 0);
			result = IDOK;
			done   = TRUE;
			break;
		case IDCANCEL:
			done   = TRUE;
			break;
		}
	}
	pMainFrame->UnPauseFlip();

	return( result );
}

int CArmyMenApp::OnGameOptionsDialog() 
{
	int				result;
	CGameOptionsDlg optionsDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	result = optionsDlg.DoModal();
	pMainFrame->UnPauseFlip();

	return( result );
}

int CArmyMenApp::OnSelectCampaignDialog() 
{
	int					result           = IDCANCEL;

	BOOL				done             = FALSE;
	CSelectCampaignDlg	selectCampaignDlg;			// ID_NEXT

	// TODO: Add your command handler code here
	while ( !done )
	{
		result = selectCampaignDlg.DoModal();
		if ( result == ID_NEXT )
		{
			result = OnMissionSelectDialog();
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}

	return( result );
}

int CArmyMenApp::OnMissionSelectDialog() 
{
	int		nNumberScenarios = g_NumberScenarios;
	int		result           = IDCANCEL;
	BOOL	done             = FALSE;

	// TODO: Add your command handler code here
	while ( !done )
	{
		switch( nNumberScenarios )
		{
		case 0:
			ShowError( IDS_NO_SCENARIOS );
			goto exit;
			break;
		case 1:
			result = OnMissionSelect1Dialog();
			break;
		case 2:
			result = OnMissionSelect2Dialog();
			break;
		case 3:
			result = OnMissionSelect3Dialog();
			break;
		case 4:
			result = OnMissionSelect4Dialog();
			break;
		default:
			result = OnMissionSelectMoreDialog();
			break;
		}

		if ( (result != ID_BACK) && (result != ID_MORE) && (result!=IDOK) )
			done = TRUE;
		else
		{
			if ( result == ID_MORE )
			{
				g_ScenarioIndex  += 4;
				nNumberScenarios -= 4;
			}

			if ( result == ID_BACK )
			{
				if ( g_ScenarioIndex )
				{
					g_ScenarioIndex  -= 4;
					nNumberScenarios += 4;
				}
				else
					done = TRUE;
			}
		}
	}
exit:
	return( result );
}

int CArmyMenApp::OnMissionSelect1Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission1Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnMissionSelect2Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission2Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnMissionSelect3Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission3Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnMissionSelect4Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission4Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnMissionSelectMoreDialog() 
{
	int						result = IDCANCEL;
	CSelectMissionMoreDlg	missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnMultiPlyrSelectCampaignDialog() 
{
	int							result = IDCANCEL;
	CMultiPlyrCampaignSelectDlg multiPlyrDlg;

	// TODO: Add your command handler code here
	result = multiPlyrDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnJoinArmySelectDialog() 
{
	int					result = IDCANCEL;
	CJoinArmySelectDlg	armySelectDlg;

	// TODO: Add your command handler code here
	result = armySelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CArmyMenApp::OnTitleScreenDialog() 
{
	BOOL		done = FALSE;
	int			result = IDCANCEL;
	CTitleDlg	titleDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	while ( !done )
	{
		result = titleDlg.DoModal();
		switch( result )
		{
		case IDC_ONEPLYR:
			result = OnSelectCampaignDialog();
			if ( result != ID_BACK )
				done = TRUE;
			break;
		case IDC_MULTIPLYR:
//			pMainFrame->SetMultiPlayer( gameStartDlg.m_MultiPlayerButton );
			if ( gpComm->IsConnected() == FALSE )
				result = OnServiceProviderDialog();
			else
				result = OnMultiPlyrSelectCampaignDialog();

			if ( result != ID_BACK )
				done = TRUE;
			break;
		case IDC_OPTIONS:
			result = OnGameOptionsDialog();
			done   = TRUE;
			break;
		case IDC_QUIT:
			pMainFrame->PostMessage(WM_CLOSE, 0, 0);
			result = IDOK;
			done   = TRUE;
			break;
		}
	}
	SetPath(CAMPAIGN_PATH);
	AiCampaignLoad( "campaign.cpn" );

	if ( result == IDC_ONEPLYR )
		pMainFrame->StartGame();	// start the game
	if ( result == IDC_MULTIPLYR )
		pMainFrame->StartGame();	// start the game
	if ( result == IDC_OPTIONS )
		pMainFrame->StartGame();	// start the game
	if ( result == IDC_QUIT )
		pMainFrame->StartGame();	// start the game

	return( result );
}


void CArmyMenApp::OnScrnHostTest() 
{
	audioDisable();
	gpGame->SetSubState(NULL_SUB_STATE);
	gpGame->SetState( GAME_TITLE_SCREEN_STATE );
	ScrnSetState( SCRN_MULTI_HOST_STATE );
	ScrnUpdateHost();
}

void CArmyMenApp::OnScrnRemoteTest() 
{
	audioDisable();
	gpGame->SetSubState(NULL_SUB_STATE);
	gpGame->SetState( GAME_TITLE_SCREEN_STATE );
	ScrnSetState( SCRN_MULTI_REMOTE_STATE );
	ScrnUpdateRemote();
}



--------



int CArmyMenApp::OnServiceProviderDialog() 
{
	int				result;
	BOOL			done = FALSE;
	CProviderDlg	providerDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	while ( !done )
	{
		result = providerDlg.DoModal();
		if ( result == ID_NEXT )
		{
			result = OnGameSetupDialog();	// try the next dialog box
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}
	pMainFrame->UnPauseFlip();

	return( result );
}

int CArmyMenApp::OnGameSetupDialog() 
{
	int				result  = IDCANCEL;
	BOOL			done    = FALSE;
	CGameSetupDlg	gameSetupDlg;

	// TODO: Add your command handler code here
	while ( !done )
	{
		result = gameSetupDlg.DoModal();
		if ( result == ID_NEXT )
		{
			result = gameSetupDlg.OnSessionType();
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}

	return( result );
}

int CArmyMenApp::OnHostSessionDialog() 
{
	int				result  = IDCANCEL;
	BOOL			done    = FALSE;
	CHostSessionDlg hostSessionDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	while ( !done )
	{
		result = hostSessionDlg.DoModal();
		if ( result == ID_NEXT )
		{
			if ( pMainFrame->IsMultiPlayer() )
				result = OnMultiPlyrSelectCampaignDialog();
			else
				result = OnSelectCampaignDialog();
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}
	pMainFrame->UnPauseFlip();

	return( result );
}

int CArmyMenApp::OnJoinSessionDialog() 
{
	int				result  = IDCANCEL;
	BOOL			done    = FALSE;
	CJoinSessionDlg joinSessionDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	while ( !done )
	{
		result = joinSessionDlg.DoModal();
		if ( result == ID_NEXT )
		{
			result = OnJoinArmySelectDialog();
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}
	pMainFrame->UnPauseFlip();

	return( result );
}

---------


void CArmyMenApp::OnTestGameStartDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnGameStartDialog();
}

void CArmyMenApp::OnTestGameOptionsDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnGameOptionsDialog();
}

void CArmyMenApp::OnTestServiceProviderDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnServiceProviderDialog();
}

void CArmyMenApp::OnTestGameSetupDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnGameSetupDialog();
}

void CArmyMenApp::OnTestHostSessionDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnHostSessionDialog();
}

void CArmyMenApp::OnTestJoinSessionDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnJoinSessionDialog();
}

void CArmyMenApp::OnTestSelectCampaignDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnSelectCampaignDialog();
}

void CArmyMenApp::OnTestSelectMissionDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnMissionSelectDialog();
}

void CArmyMenApp::OnTestMultiPlyrSelectCampaignDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnMultiPlyrSelectCampaignDialog();
}

void CArmyMenApp::OnTestJoinArmySelectDialog() 
{
	int		result;

	// TODO: Add your command handler code here
	result = OnJoinArmySelectDialog();
}

void CArmyMenApp::OnTestTitleScreenDialog() 
{
	int		result;

	SetPath( SCREEN_PATH );
	MakeIdentityPalette( "Title_legal.bmp", &pMainFrame->GamePalette );
	pMainFrame->ForceFullScreen();
	result = OnTitleScreenDialog();
}

--------


//----------------------------------------------------------------
//	Game Connect State
//----------------------------------------------------------------
void New_GAME_CONNECT_STATE( GAME_STATE gameState )
{
	int		result = IDCANCEL;
	ULONG	nSndID = SND_NULL_SND_ID;

	gpGame->PauseGame( PAUSE_TITLE );
	pDirectDraw->FlipToGDISurface();

	pMainFrame->SetUI(NULL);
	pMainFrame->SetUIOverride(KeyOverride_GAME_CONNECT_STATE);

	// load the Team image
  	LoadBackground( "3do.bmp", TRUE );

	// start the connect titlescreen

	if ( gpComm->IsConnected() == FALSE )
	{
		result = theApp.OnServiceProviderDialog();
		if ( result == IDCANCEL )
			gpGame->SetState( GAME_TITLE_SCREEN_STATE );
	}
	else
	{
		result = theApp.OnMultiPlyrSelectCampaignDialog();
		if ( result != ID_FINISH )
			gpGame->SetState( GAME_TITLE_SCREEN_STATE );
	}
}

void Old_GAME_CONNECT_STATE( GAME_STATE gameState )
{
	FreeSprite(&BackgroundSprite);
	EraseVisibleSurface();
	gpGame->UnPauseGame( PAUSE_TITLE );
}

BOOL GLd_GAME_CONNECT_STATE( void )
{
	return (TRUE);
}

void Dsp_GAME_CONNECT_STATE( void )
{
	return;
}

void Act_GAME_CONNECT_STATE( void )
{
	return;
}

BOOL KeyOverride_GAME_CONNECT_STATE(UINT key, BOOL down)
{
	BOOL	bKeyUsed = FALSE;		// key ignored
#if 0
	if (down && key == VK_ESCAPE)
	{
		pMainFrame->PostMessage(WM_CLOSE, 0, 0);
		bKeyUsed = TRUE;			// key used
	}
#endif

	return( bKeyUsed );
}

extern	void	New_GAME_CONNECT_STATE( GAME_STATE gameState );
extern	void	Old_GAME_CONNECT_STATE( GAME_STATE gameState );
extern	BOOL	GLd_GAME_CONNECT_STATE( void );
extern	void	Dsp_GAME_CONNECT_STATE( void );
extern	void	Act_GAME_CONNECT_STATE( void );
extern	BOOL	KeyOverride_GAME_CONNECT_STATE(UINT key, BOOL down);


-----

		case UM_CONNECT_SETUP:
		case UM_TDG_LAUNCH:
			if (gpComm->debugComm ) TRACE("Windows Message UM_TDG_LAUNCHGAME\n");
			break;
		case UM_TDG_ABORT:
			ASSERT(0);	// shouldn't be here
			break;


-------

	int			OnSelectCampaignDialog(); 
	int			OnMultiPlyrSelectCampaignDialog(); 


int CMainFrame::OnSelectCampaignDialog() 
{
	int					result = IDCANCEL;
	BOOL				done   = FALSE;
	CSelectCampaignDlg	selectCampaignDlg;			// ID_NEXT

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();

	// TODO: Add your command handler code here
	while ( !done )
	{
		result = selectCampaignDlg.DoModal();
		if ( result == ID_NEXT )
		{
			result = OnMissionSelectDialog();
			if ( result != ID_BACK )
				done = TRUE;
		}
		else
			done = TRUE;
	}
	pMainFrame->UnPauseFlip();

	return( result );
}


int CMainFrame::OnMultiPlyrSelectCampaignDialog() 
{
	int							result = IDCANCEL;
	CMultiPlyrCampaignSelectDlg multiPlyrDlg;

	// TODO: Add your command handler code here
	pMainFrame->PauseFlip();
	result = multiPlyrDlg.DoModal();
	ASSERT( result != ID_FINISH );
	if ( result == IDOK )
		StartGame();	// start the game
	pMainFrame->UnPauseFlip();

	return( result );
}

void CMainFrame::OnOnePlayer() 
{
	if ( gpComm->IsConnected() == FALSE )
	{
		multiPlayer        = FALSE;
		disableMultiPlayer = TRUE;
		disconnectPlayer   = FALSE;
		gpGame->GameType   = GAMETYPE_ONEPLAYER;
		SetPath(CAMPAIGN_PATH);
		AiCampaignLoad( "campaign.cpn" );
		StartGame();		// wizard Property sheet controls
	}
}

void CMainFrame::OnUpdateOnePlayer(CCmdUI* pCmdUI) 
{
	if ( gpGame->GetState() != GAME_MOVIE_STATE )
	{
		if ( gpComm->IsConnected() == FALSE )
		{
			pCmdUI->Enable(gpGame->GameType == GAMETYPE_ONEPLAYER);
			gpGame->GameType = GAMETYPE_ONEPLAYER;
		}
		else
			pCmdUI->Enable(FALSE);
	}
	else
		pCmdUI->Enable(FALSE);
}

void CMainFrame::OnTwoPlayer() 
{
}

void CMainFrame::OnUpdateTwoPlayer(CCmdUI* pCmdUI) 
{
}

// temp hack to keep multi-player working while we bring up the new UI
extern BOOL useMPUI;

void CMainFrame::OnMultiPlayer() 
{
	multiPlayer        = TRUE;
	disableMultiPlayer = FALSE;
	disconnectPlayer   = TRUE;
	gpGame->GameType   = GAMETYPE_REMOTE_MULTIPLAYER;
	useMPUI = FALSE;
	if ( gpComm->IsConnected() == FALSE )
	{
		gpGame->start_game = TRUE;

		OnServiceProviderDialog();
	}
	else
	{
		SetPath(CAMPAIGN_PATH);
		AiCampaignLoad( "campaign.cpn" );
		StartGame();
	}
}

void CMainFrame::OnUpdateMultiPlayer(CCmdUI* pCmdUI) 
{
	if ( gpGame->GetState() != GAME_MOVIE_STATE )
        pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);
}

void CMainFrame::OnDisconnect() 
{
	gpComm->Disconnect();
	multiPlayer        = TRUE;
	disableMultiPlayer = FALSE;
	disconnectPlayer   = FALSE;
}

void CMainFrame::OnUpdateDisconnect(CCmdUI* pCmdUI) 
{
	if ( gpGame->GetState() != GAME_MOVIE_STATE )
		pCmdUI->Enable(!disconnectPlayer);
	else
		pCmdUI->Enable(FALSE);	
}
	afx_msg void OnUpdateOnePlayer(CCmdUI* pCmdUI);
	afx_msg void OnOnePlayer();
	afx_msg void OnUpdateTwoPlayer(CCmdUI* pCmdUI);
	afx_msg void OnTwoPlayer();
	afx_msg void OnUpdateMultiPlayer(CCmdUI* pCmdUI);
	afx_msg void OnMultiPlayer();
	afx_msg void OnUpdateDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnDisconnect();



/////////////////////////////////////////////////////////////////////////////
// CSelectMission1Dlg dialog


CSelectMission1Dlg::CSelectMission1Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectMission1Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectMission1Dlg)
		// NOTE: the ClassWizard will add member initialization here
	m_MissionID      = -1;
	m_ScenarioIndex  = 0;
	m_ItemIndex      = 0; 
	m_hPrev          = NULL; 
	m_hPrevRootItem  = NULL; 
	m_hPrevLev2Item  = NULL; 
	m_hPrevLev3Item  = NULL;
	m_FirstSelection = FALSE;
	m_htiVisible     = FALSE;
	//}}AFX_DATA_INIT
}


void CSelectMission1Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectMission1Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectMission1Dlg, CDialog)
	//{{AFX_MSG_MAP(CSelectMission1Dlg)
	ON_BN_CLICKED(ID_BACK, OnSelectMission1Back)
	ON_BN_CLICKED(IDCANCEL, OnSelectMission1Cancel)
	ON_BN_CLICKED(ID_FINISH, OnSelectMission1Finish)
	ON_LBN_SELCHANGE(IDC_MISSIONS_0, OnSelectMission1Selchanged0)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMissionSelect1Dlg message handlers

BOOL CSelectMission1Dlg::OnInitDialog() 
{
	int				nIndex;
	CAMPAIGNREF*	pCampaignRef;
	SCENARIOREF*	pScenarioRef;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_ItemIndex      = 0; 
	m_FirstSelection = FALSE;
	m_ScenarioID     = -1;

	// now enumerate the data
	pCampaignRef = AiGetCampaignRef( gAMCampaignID );
	if ( !pCampaignRef )
		return( FALSE );

	//set up the list
	m_CWndCtlMaps = GetDlgItem( IDC_MISSIONS_0 );
	if ( m_CWndCtlMaps == NULL)
		return(TRUE);
	gCWndCtlMaps = m_CWndCtlMaps;

	// initialize and clear the list
	nIndex = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );

	pScenarioRef = &(pCampaignRef->pScenarios[ g_ScenarioIndex ]);
	m_ScenarioID = pScenarioRef->nScenarioID;
	DLGEnumBattles( pScenarioRef, gCWndCtlMaps, 0 );

 	// now initialize the current selection
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
	
	// initialize this global references
	m_pItemIndex        = &m_ItemIndex;
	m_pFirstSelection   = &m_FirstSelection;
	m_pScenarioID       = &m_ScenarioID;
	m_pCWndCtlMaps      = m_CWndCtlMaps;
	gCWndCtlMaps        = m_pCWndCtlMaps;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectMission1Dlg::OnSelectMission1Back() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_BACK );
}

void CSelectMission1Dlg::OnSelectMission1Finish() 
{
	LONG			nID;
	MISSIONREF*		pMissionRef;
	SCENARIOREF*	pScenarioRef;
	CAMPAIGNREF*	pCampaignRef;

	// TODO: Add your control notification handler code here
	if ( gCWndCtlMaps == NULL )
		goto hadError;

	m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (m_ItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nID = (int) gCWndCtlMaps->SendMessage( LB_GETITEMDATA, m_ItemIndex, 0 );
		if ( nID >= DLG_CAMPAIGN_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_SCENARIO_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_MISSION_ID_BASE )
			m_MissionID = nID;

        if (m_MissionID)	// get the string name for this file and set the gpGame
		{
			// now, using campaign, scenario, and mission IDs, find the file name
			pCampaignRef    = g_Campaigns[g_CampaignIndex ];
			if ( !pCampaignRef )
				goto hadError;
			pScenarioRef    = AiGetScenarioRef( pCampaignRef, *m_pScenarioID );
			if ( !pScenarioRef )
				goto hadError;
			pMissionRef     = AiGetMissionRef( pScenarioRef, m_MissionID );
			if ( !pMissionRef )
				goto hadError;
			gpGame->MapName = pMissionRef->pFileName;
		}
    }

	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
	return;
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
}

void CSelectMission1Dlg::OnSelectMission1Cancel() 
{
	// TODO: Add your control notification handler code here
	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectMission1Dlg::OnSelectMission1Selchanged0() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_pScenarioID  = &m_ScenarioID;
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSelectMission2Dlg dialog


CSelectMission2Dlg::CSelectMission2Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectMission2Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectMission2Dlg)
		// NOTE: the ClassWizard will add member initialization here
	m_MissionID         = -1;
	m_ScenarioIndex     = 0;
	m_WhichList         = 0;
	//}}AFX_DATA_INIT
}


void CSelectMission2Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectMission2Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectMission2Dlg, CDialog)
	//{{AFX_MSG_MAP(CSelectMission2Dlg)
	ON_BN_CLICKED(ID_BACK, OnSelectMission2Back)
	ON_BN_CLICKED(IDCANCEL, OnSelectMission2Cancel)
	ON_BN_CLICKED(ID_FINISH, OnSelectMission2Finish)
	ON_LBN_SELCHANGE(IDC_MISSIONS_0, OnSelectMission2Selchanged0)
	ON_LBN_SELCHANGE(IDC_MISSIONS_1, OnSelectMission2Selchanged1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectMission2Dlg message handlers

BOOL CSelectMission2Dlg::OnInitDialog() 
{
	int				nList;
	int				nIndex;
	int				nMission;
	int				nListIndex;
	CAMPAIGNREF*	pCampaignRef;
	SCENARIOREF*	pScenarioRef;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	for ( nIndex=0; nIndex<2; ++nIndex )
	{
		m_ItemIndex[ nIndex ]      = 0; 
		m_FirstSelection[ nIndex ] = FALSE;
		m_ScenarioID[ nIndex ]     = -1;
	}

	// now enumerate the data
	pCampaignRef = AiGetCampaignRef( gAMCampaignID );
	if ( !pCampaignRef )
		return( FALSE );
	nListIndex = g_ScenarioIndex;

	//set up the lists
	for( nList=0; nList<2; ++nList )
	{
		// determine which list to initialize.
		switch( nList )
		{
		case 0:
			nMission = IDC_MISSIONS_0;
			break;
		case 1:
			nMission = IDC_MISSIONS_1;
			break;
		}
		m_CWndCtlMaps[ nList ] = GetDlgItem( nMission );
		if ( m_CWndCtlMaps[ nList ] == NULL)
			return(TRUE);
		gCWndCtlMaps = m_CWndCtlMaps[ nList ];

		// initialize and clear the list
		nIndex = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );

		pScenarioRef = &(pCampaignRef->pScenarios[ nListIndex ]);
		m_ScenarioID[ nList ] = pScenarioRef->nScenarioID;
		DLGEnumBattles( pScenarioRef, gCWndCtlMaps, nList );
		if ( nList == 0)
		{
			m_pItemIndex = &(m_ItemIndex[nList]);
			gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex[ nList ], 0 );
		}

		++nListIndex;
	}

	// initialize this global references
	m_pItemIndex        = &m_ItemIndex[0];
	m_pFirstSelection   = &m_FirstSelection[0];
	m_phtiVisible       = &m_htiVisible[0];
	m_pScenarioID       = &m_ScenarioID[0];
	m_pCWndCtlMaps      = m_CWndCtlMaps[0];
	gCWndCtlMaps        = m_pCWndCtlMaps;

 	// now initialize the current selection
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, *m_pItemIndex, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectMission2Dlg::OnSelectMission2Back() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_BACK );
}

void CSelectMission2Dlg::OnSelectMission2Finish() 
{
	LONG			nID;
	LONG			nItemIndex;
	MISSIONREF*		pMissionRef;
	SCENARIOREF*	pScenarioRef;
	CAMPAIGNREF*	pCampaignRef;

	// TODO: Add your control notification handler code here
	if ( m_pCWndCtlMaps == NULL )
		goto hadError;

	nItemIndex = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (nItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nID = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, nItemIndex, 0 );
		if ( nID >= DLG_SCENARIO_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_MISSION_ID_BASE )
			m_MissionID = nID;

        if (m_MissionID)	// get the string name for this file and set the gpGame
		{
			// now, using campaign, scenario, and mission IDs, find the file name
			pCampaignRef    = g_Campaigns[g_CampaignIndex ];
			if ( !pCampaignRef )
				goto hadError;
			pScenarioRef    = AiGetScenarioRef( pCampaignRef, *m_pScenarioID );
			if ( !pScenarioRef )
				goto hadError;
			pMissionRef     = AiGetMissionRef( pScenarioRef, m_MissionID );
			if ( !pMissionRef )
				goto hadError;
			gpGame->MapName = pMissionRef->pFileName;
		}
    }

	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
	return;
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
}

void CSelectMission2Dlg::OnSelectMission2Cancel() 
{
	// TODO: Add your control notification handler code here
	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectMission2Dlg::OnSelectMission2Selchanged0() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 0;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission2Dlg::OnSelectMission2Selchanged1() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 1;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSelectMission3Dlg dialog


CSelectMission3Dlg::CSelectMission3Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectMission3Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectMission3Dlg)
		// NOTE: the ClassWizard will add member initialization here
	m_MissionID         = -1;
	m_ScenarioIndex     = 0;
	m_WhichList         = 0;
	//}}AFX_DATA_INIT
}


void CSelectMission3Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectMission3Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectMission3Dlg, CDialog)
	//{{AFX_MSG_MAP(CSelectMission3Dlg)
	ON_BN_CLICKED(ID_BACK, OnSelectMission3Back)
	ON_BN_CLICKED(IDCANCEL, OnSelectMission3Cancel)
	ON_BN_CLICKED(ID_FINISH, OnSelectMission3Finish)
	ON_LBN_SELCHANGE(IDC_MISSIONS_0, OnSelectMission3Selchanged0)
	ON_LBN_SELCHANGE(IDC_MISSIONS_1, OnSelectMission3Selchanged1)
	ON_LBN_SELCHANGE(IDC_MISSIONS_2, OnSelectMission3Selchanged2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectMission3Dlg message handlers

BOOL CSelectMission3Dlg::OnInitDialog() 
{
	int				nList;
	int				nIndex;
	int				nMission;
	int				nListIndex;
	CAMPAIGNREF*	pCampaignRef;
	SCENARIOREF*	pScenarioRef;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	for ( nIndex=0; nIndex<3; ++nIndex )
	{
		m_ItemIndex[ nIndex ]      = 0; 
		m_FirstSelection[ nIndex ] = FALSE;
		m_ScenarioID[ nIndex ]     = -1;
	}

	// now enumerate the data
	pCampaignRef = AiGetCampaignRef( gAMCampaignID );
	if ( !pCampaignRef )
		return( FALSE );
	nListIndex = g_ScenarioIndex;

	//set up the lists
	for( nList=0; nList<3; ++nList )
	{
		// determine which list to initialize.
		switch( nList )
		{
		case 0:
			nMission = IDC_MISSIONS_0;
			break;
		case 1:
			nMission = IDC_MISSIONS_1;
			break;
		case 2:
			nMission = IDC_MISSIONS_2;
			break;
		}
		m_CWndCtlMaps[ nList ] = GetDlgItem( nMission );
		if ( m_CWndCtlMaps[ nList ] == NULL)
			return(TRUE);
		gCWndCtlMaps = m_CWndCtlMaps[ nList ];

		// initialize and clear the list
		nIndex = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );

		pScenarioRef        = &(pCampaignRef->pScenarios[ nListIndex ]);
		m_ScenarioID[nList] = pScenarioRef->nScenarioID;
		DLGEnumBattles( pScenarioRef, gCWndCtlMaps, nList );
		gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex[nList], 0 );

		++nListIndex;
	}

	// initialize this global references
	m_pItemIndex        = &m_ItemIndex[0];
	m_pFirstSelection   = &m_FirstSelection[0];
	m_phtiVisible       = &m_htiVisible[0];
	m_pScenarioID       = &m_ScenarioID[0];
	m_pCWndCtlMaps      = m_CWndCtlMaps[0];
	gCWndCtlMaps        = m_pCWndCtlMaps;

 	// now initialize the current selection
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, *m_pItemIndex, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectMission3Dlg::OnSelectMission3Back() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_BACK );
}

void CSelectMission3Dlg::OnSelectMission3Finish() 
{
	LONG			nID;
	LONG			nItemIndex;
	MISSIONREF*		pMissionRef;
	SCENARIOREF*	pScenarioRef;
	CAMPAIGNREF*	pCampaignRef;

	// TODO: Add your control notification handler code here
	if ( m_pCWndCtlMaps == NULL )
		goto hadError;

	nItemIndex = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (nItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nID = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, nItemIndex, 0 );
		if ( nID >= DLG_SCENARIO_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_MISSION_ID_BASE )
			m_MissionID = nID;

        if (m_MissionID)	// get the string name for this file and set the gpGame
		{
			// now, using campaign, scenario, and mission IDs, find the file name
			pCampaignRef    = g_Campaigns[g_CampaignIndex ];
			if ( !pCampaignRef )
				goto hadError;
			pScenarioRef    = AiGetScenarioRef( pCampaignRef, *m_pScenarioID );
			if ( !pScenarioRef )
				goto hadError;
			pMissionRef     = AiGetMissionRef( pScenarioRef, m_MissionID );
			if ( !pMissionRef )
				goto hadError;
			gpGame->MapName = pMissionRef->pFileName;
		}
    }

	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
	return;
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
}

void CSelectMission3Dlg::OnSelectMission3Cancel() 
{
	// TODO: Add your control notification handler code here
	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectMission3Dlg::OnSelectMission3Selchanged0() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 0;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission3Dlg::OnSelectMission3Selchanged1() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 1;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission3Dlg::OnSelectMission3Selchanged2() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 2;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSelectMission4Dlg dialog


CSelectMission4Dlg::CSelectMission4Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectMission4Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectMission4Dlg)
		// NOTE: the ClassWizard will add member initialization here
	m_MissionID         = -1;
	m_ScenarioIndex     = 0;
	m_WhichList         = 0;
	//}}AFX_DATA_INIT
}


void CSelectMission4Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectMission4Dlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectMission4Dlg, CDialog)
	//{{AFX_MSG_MAP(CSelectMission4Dlg)
	ON_BN_CLICKED(ID_BACK, OnSelectMission4Back)
	ON_BN_CLICKED(IDCANCEL, OnSelectMission4Cancel)
	ON_BN_CLICKED(ID_FINISH, OnSelectMission4Finish)
	ON_LBN_SELCHANGE(IDC_MISSIONS_0, OnSelectMission4Selchanged0)
	ON_LBN_SELCHANGE(IDC_MISSIONS_1, OnSelectMission4Selchanged1)
	ON_LBN_SELCHANGE(IDC_MISSIONS_2, OnSelectMission4Selchanged2)
	ON_LBN_SELCHANGE(IDC_MISSIONS_3, OnSelectMission4Selchanged3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectMission4Dlg message handlers

BOOL CSelectMission4Dlg::OnInitDialog() 
{
	int				nList;
	int				nIndex;
	int				nMission;
	int				nListIndex;
	CAMPAIGNREF*	pCampaignRef;
	SCENARIOREF*	pScenarioRef;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	for ( nIndex=0; nIndex<4; ++nIndex )
	{
		m_ItemIndex[ nIndex ]      = 0; 
		m_FirstSelection[ nIndex ] = FALSE;
		m_ScenarioID[ nIndex ]     = -1; 
	}

	// now enumerate the data
	pCampaignRef = AiGetCampaignRef( gAMCampaignID );
	if ( !pCampaignRef )
		return( FALSE );
	nListIndex = g_ScenarioIndex;

	//set up the lists
	for( nList=0; nList<4; ++nList )
	{
		// determine which list to initialize.
		switch( nList )
		{
		case 0:
			nMission = IDC_MISSIONS_0;
			break;
		case 1:
			nMission = IDC_MISSIONS_1;
			break;
		case 2:
			nMission = IDC_MISSIONS_2;
			break;
		case 3:
			nMission = IDC_MISSIONS_3;
			break;
		}
		m_CWndCtlMaps[ nList ] = GetDlgItem( nMission );
		if ( m_CWndCtlMaps[ nList ] == NULL)
			return(TRUE);
		gCWndCtlMaps = m_CWndCtlMaps[ nList ];

		// initialize and clear the list
		nIndex = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );

		pScenarioRef = &(pCampaignRef->pScenarios[ nListIndex ]);
		m_ScenarioID[ nList ] = pScenarioRef->nScenarioID;
		DLGEnumBattles( pScenarioRef, gCWndCtlMaps, nList );
		if ( nList == 0)
		{
			m_pItemIndex = &(m_ItemIndex[nList]);
			gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex[ nList ], 0 );
		}

		++nListIndex;
	}

	// initialize this global references
	m_pItemIndex        = &m_ItemIndex[0];
	m_pFirstSelection   = &m_FirstSelection[0];
	m_pScenarioID       = &m_ScenarioID[0];
	m_pCWndCtlMaps      = m_CWndCtlMaps[0];
	gCWndCtlMaps        = m_pCWndCtlMaps;

 	// now initialize the current selection
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, *m_pItemIndex, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectMission4Dlg::OnSelectMission4Back() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_BACK );
}

void CSelectMission4Dlg::OnSelectMission4Finish() 
{
	LONG			nID;
	LONG			nItemIndex;
	MISSIONREF*		pMissionRef;
	SCENARIOREF*	pScenarioRef;
	CAMPAIGNREF*	pCampaignRef;

	// TODO: Add your control notification handler code here
	switch( m_WhichList )
	{
	case 0:		// IDC_MISSION_0
		m_pCWndCtlMaps = m_CWndCtlMaps[0];
		break;
	case 1:		// IDC_MISSION_1
		m_pCWndCtlMaps = m_CWndCtlMaps[1];
		break;
	case 2:		// IDC_MISSION_2
		m_pCWndCtlMaps = m_CWndCtlMaps[2];
		break;
	case 3:		// IDC_MISSION_3
		m_pCWndCtlMaps = m_CWndCtlMaps[3];
		break;
	}
	if ( m_pCWndCtlMaps == NULL )
		goto hadError;

	nItemIndex = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (nItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nID = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, nItemIndex, 0 );
		if ( nID >= DLG_SCENARIO_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_MISSION_ID_BASE )
			m_MissionID = nID;

        if (m_MissionID)	// get the string name for this file and set the gpGame
		{
			// now, using campaign, scenario, and mission IDs, find the file name
			pCampaignRef    = g_Campaigns[g_CampaignIndex ];
			if ( !pCampaignRef )
				goto hadError;
			pScenarioRef    = AiGetScenarioRef( pCampaignRef, *m_pScenarioID );
			if ( !pScenarioRef )
				goto hadError;
			pMissionRef     = AiGetMissionRef( pScenarioRef, m_MissionID );
			if ( !pMissionRef )
				goto hadError;
			gpGame->MapName = pMissionRef->pFileName;
		}
    }
	else
	{
		ShowError( IDS_NEED_MISSION );
		goto hadError;
	}

	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
	return;
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
}

void CSelectMission4Dlg::OnSelectMission4Cancel() 
{
	// TODO: Add your control notification handler code here
//	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectMission4Dlg::OnSelectMission4Selchanged0() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 0;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission4Dlg::OnSelectMission4Selchanged1() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 1;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission4Dlg::OnSelectMission4Selchanged2() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 2;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMission4Dlg::OnSelectMission4Selchanged3() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 3;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSelectMissionMoreDlg dialog


CSelectMissionMoreDlg::CSelectMissionMoreDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectMissionMoreDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectMissionMoreDlg)
		// NOTE: the ClassWizard will add member initialization here
	m_MissionID         = -1;
	m_ScenarioIndex     = 0;
	m_WhichList         = 0;
	//}}AFX_DATA_INIT
}


void CSelectMissionMoreDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectMissionMoreDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectMissionMoreDlg, CDialog)
	//{{AFX_MSG_MAP(CSelectMissionMoreDlg)
	ON_BN_CLICKED(ID_BACK, OnSelectMissionMoreBack)
	ON_BN_CLICKED(ID_MORE, OnSelectMissionMoreMore)
	ON_BN_CLICKED(IDCANCEL, OnSelectMissionMoreCancel)
	ON_BN_CLICKED(ID_FINISH, OnSelectMissionMoreFinish)
	ON_LBN_SELCHANGE(IDC_MISSIONS_0, OnSelectMissionMoreSelchanged0)
	ON_LBN_SELCHANGE(IDC_MISSIONS_1, OnSelectMissionMoreSelchanged1)
	ON_LBN_SELCHANGE(IDC_MISSIONS_2, OnSelectMissionMoreSelchanged2)
	ON_LBN_SELCHANGE(IDC_MISSIONS_3, OnSelectMissionMoreSelchanged3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectMissionMoreDlg message handlers

BOOL CSelectMissionMoreDlg::OnInitDialog() 
{
	int				nList;
	int				nIndex;
	int				nMission;
	int				nListIndex;
	CAMPAIGNREF*	pCampaignRef;
	SCENARIOREF*	pScenarioRef;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	for ( nIndex=0; nIndex<4; ++nIndex )
	{
		m_ItemIndex[ nIndex ]      = 0; 
		m_FirstSelection[ nIndex ] = FALSE;
		m_ScenarioID[ nIndex ]     = -1;
	}

	// now enumerate the data
	pCampaignRef = AiGetCampaignRef( gAMCampaignID );
	if ( !pCampaignRef )
		return( FALSE );
	nListIndex = g_ScenarioIndex;

	//set up the lists
	for( nList=0; nList<4; ++nList )
	{
		// determine which list to initialize.
		switch( nList )
		{
		case 0:
			nMission = IDC_MISSIONS_0;
			break;
		case 1:
			nMission = IDC_MISSIONS_1;
			break;
		case 2:
			nMission = IDC_MISSIONS_2;
			break;
		case 3:
			nMission = IDC_MISSIONS_3;
			break;
		}
		m_CWndCtlMaps[ nList ] = GetDlgItem( nMission );
		if ( m_CWndCtlMaps[ nList ] == NULL)
			return(TRUE);
		gCWndCtlMaps         = m_CWndCtlMaps[ nList ];

		// initialize and clear the list
		nIndex = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );

		pScenarioRef        = &(pCampaignRef->pScenarios[ nListIndex ]);
		m_ScenarioID[nList] = pScenarioRef->nScenarioID;
		DLGEnumBattles( pScenarioRef, gCWndCtlMaps, nList );
		m_pItemIndex        = &(m_ItemIndex[nList]);
		gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex[ nList ], 0 );

		++nListIndex;
	}

	// initialize this global references
	m_pItemIndex        = &m_ItemIndex[0];
	m_pFirstSelection   = &m_FirstSelection[0];
	m_phtiVisible       = &m_htiVisible[0];
	m_pScenarioID       = &(m_ScenarioID[0]);
	m_pCWndCtlMaps      = m_CWndCtlMaps[0];
	gCWndCtlMaps        = m_pCWndCtlMaps;

 	// now initialize the current selection
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, *m_pItemIndex, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectMissionMoreDlg::OnSelectMissionMoreBack() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_BACK );
}

void CSelectMissionMoreDlg::OnSelectMissionMoreMore() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_MORE );
}

void CSelectMissionMoreDlg::OnSelectMissionMoreFinish() 
{
	LONG			nID;
	LONG			nItemIndex;
	MISSIONREF*		pMissionRef;
	SCENARIOREF*	pScenarioRef;
	CAMPAIGNREF*	pCampaignRef;

	// TODO: Add your control notification handler code here
	if ( m_pCWndCtlMaps == NULL )
		goto hadError;

	nItemIndex = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (nItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nID = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, nItemIndex, 0 );
		if ( nID >= DLG_SCENARIO_ID_BASE )
		{
			ShowError( IDS_NEED_MISSION );
			goto hadError;
		}
		else
		if ( nID >= DLG_MISSION_ID_BASE )
			m_MissionID = nID;

        if (m_MissionID)	// get the string name for this file and set the gpGame
		{
			// now, using campaign, scenario, and mission IDs, find the file name
			pCampaignRef    = g_Campaigns[g_CampaignIndex ];
			if ( !pCampaignRef )
				goto hadError;
			pScenarioRef    = AiGetScenarioRef( pCampaignRef, *m_pScenarioID );
			if ( !pScenarioRef )
				goto hadError;
			pMissionRef     = AiGetMissionRef( pScenarioRef, m_MissionID );
			if ( !pMissionRef )
				goto hadError;
			gpGame->MapName = pMissionRef->pFileName;
		}
    }

	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
	return;
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
}

void CSelectMissionMoreDlg::OnSelectMissionMoreCancel() 
{
	// TODO: Add your control notification handler code here
	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectMissionMoreDlg::OnSelectMissionMoreSelchanged0() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 0;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMissionMoreDlg::OnSelectMissionMoreSelchanged1() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 1;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMissionMoreDlg::OnSelectMissionMoreSelchanged2() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 2;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}

void CSelectMissionMoreDlg::OnSelectMissionMoreSelchanged3() 
{
	LONG	nData;

	// TODO: Add your control notification handler code here
	m_WhichList    = 3;
	m_pCWndCtlMaps = m_CWndCtlMaps[m_WhichList];
	m_pItemIndex   = &(m_ItemIndex[m_WhichList]);
	m_pScenarioID  = &(m_ScenarioID[m_WhichList]);
	*m_pItemIndex  = m_pCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    if (*m_pItemIndex != LB_ERR)
    {
		// this had better be a MISSION ID
        nData = (int) m_pCWndCtlMaps->SendMessage( LB_GETITEMDATA, *m_pItemIndex, 0 );

		// access the treeview for the campaign maps.
		if ( nData < DLG_SCENARIO_ID_BASE )
			m_MissionID = nData;
	}
}
/////////////////////////////////////////////////////////////////////////////
// CMultiPlyrCampaignSelectDlg message handlers

BOOL CMultiPlyrCampaignSelectDlg::OnInitDialog() 
{
	HWND	hTreeCtl;
	char**	pFileNames;
	int		nIndex;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	ghAMPrev = (HTREEITEM) TVI_FIRST; 
	ghAMPrevRootItem = NULL; 
	ghAMPrevLev2Item = NULL; 
	ghAMPrevLev3Item = NULL; 

    // access the treeview for the campaign maps.
	gCWndCtlMaps = GetDlgItem( IDC_MULTI_CAMPAIGN_MAPS );
	if (gCWndCtlMaps == NULL)
		return(TRUE);

	// initialize and clear the treeview list
    hTreeCtl = gCWndCtlMaps->m_hWnd;
    if (hTreeCtl == NULL)
		return FALSE;
	DLGInitTreeLists( hTreeCtl );
	TreeView_DeleteAllItems( hTreeCtl );
	
 	// initialize the radio buttons
	m_CampaignState = DLG_NEW_MAP;				// initialize to a new game
	m_NewButton     = DLG_BUTTON_ON;			// new game CHECKED
	m_LoadButton    = DLG_BUTTON_OFF;			// load game UNCHECKED
	m_LastButton    = DLG_BUTTON_OFF;			// last game UNCHECKED
	
	// setup title fonts
    SendDlgItemMessage( IDC_SELECT_CAMPAIGN_TYPE_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_NEW_CAMPAIGN,  WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_LOAD_CAMPAIGN, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_LAST_CAMPAIGN, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );

    // New Campaigns by default
    SendDlgItemMessage( IDC_NEW_CAMPAIGN,  BM_SETCHECK, m_NewButton,  0 );
    SendDlgItemMessage( IDC_LOAD_CAMPAIGN, BM_SETCHECK, m_LoadButton, 0 );
    SendDlgItemMessage( IDC_LAST_CAMPAIGN, BM_SETCHECK, m_LastButton, 0 );

    // setup title fonts
    SendDlgItemMessage( IDC_CHOOSE_PLAYER_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0) );
    // set buttons
#if 0
    SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETSTYLE, BS_3STATE, 0 );
    SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETSTYLE, BS_3STATE, 0 );
	if ( pMainFrame->IsMultiPlayer() == FALSE )
	{
		m_BlueButton    = DLG_BUTTON_GREY;		// blue army INDETERMINATE
		m_GreyButton    = DLG_BUTTON_GREY;		// grey army INDETERMINATE
	}
#endif
    SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton,  0 );
    SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton, 0 );
    SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton, 0 );
    SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton, 0 );

	// clear the filenames list and initialize
	for ( nIndex=0;nIndex<DLG_MAX_FILES; ++nIndex )
		m_FileNames[ nIndex ] = NULL;
	pFileNames = m_FileNames;
    DLGEnumerateCampaigns( &gAMMapGuid, DLG_USER_MAP, gCWndCtlMaps, pFileNames, &m_FirstSelection );
	DumpFileNames();

    // remember the top most item
    gAMhtiVisible = TreeView_GetFirstVisible( hTreeCtl );
#if 0
	m_ItemIndex = 1;
    gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
#endif
    m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
    gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectBack() 
{
	// TODO: Add your control notification handler code here
	DLGReleaseCampaignData( m_FileNames );
    gpComm->Release();
	CDialog::EndDialog( ID_BACK );	// return the ID to go back to
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectFinish() 
{
	// TODO: Add your control notification handler code here
	CWnd*	CWndCtl;
    LPGUID  lpGuid;

	// TODO: Add your control notification handler code here
	CWndCtl = GetDlgItem( IDC_MULTI_CAMPAIGN_MAPS );
	if ( CWndCtl == NULL )
		goto exit;

	m_ItemIndex = CWndCtl->SendMessage( LB_GETCURSEL, 0, 0 );
    if (m_ItemIndex != LB_ERR)
    {
 		// get the string name for this file and set the gpGame
        lpGuid = (LPGUID) CWndCtl->SendMessage( LB_GETITEMDATA, m_ItemIndex, 0 );
        if (lpGuid)
        {
   			// get the string name for this file and set the gpGame
//			gpGame->MapName = m_FileNames[ m_ItemIndex ];
			CWndCtl->SendMessage( LB_GETTEXT, m_ItemIndex, (LPARAM)(LPCTSTR)(gpGame->MapName) );
        }
    }
    DLGReleaseCampaignData( m_FileNames );
exit:
	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );		// return the ID_FINISH value
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectCancel() 
{
	// TODO: Add your control notification handler code here
    DLGReleaseCampaignData( m_FileNames );
	gpComm->Release();

	CDialog::OnCancel();
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectBlueArmy() 
{
	if ( pMainFrame->IsMultiPlayer() == FALSE )
		return;

	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_BLUE_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	m_BlueButton = TRUE;
	SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton,  0 );
	m_GreyButton = FALSE;
	SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton,  0 );

	SendDlgItemMessage( IDC_NEW_CAMPAIGN,  BM_SETCHECK, m_NewButton,  0 );
	SendDlgItemMessage( IDC_LOAD_CAMPAIGN, BM_SETCHECK, m_LoadButton, 0 );
	SendDlgItemMessage( IDC_LAST_CAMPAIGN, BM_SETCHECK, m_LastButton, 0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectGreenArmy() 
{
	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_GREEN_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = TRUE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	if ( pMainFrame->IsMultiPlayer() )
	{
		m_BlueButton = TRUE;
		SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
		m_GreyButton = FALSE;
		SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
	}

	SendDlgItemMessage( IDC_NEW_CAMPAIGN,  BM_SETCHECK, m_NewButton,  0 );
	SendDlgItemMessage( IDC_LOAD_CAMPAIGN, BM_SETCHECK, m_LoadButton, 0 );
	SendDlgItemMessage( IDC_LAST_CAMPAIGN, BM_SETCHECK, m_LastButton, 0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectGreyArmy() 
{
	if ( pMainFrame->IsMultiPlayer() == FALSE )
		return;

	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_GREY_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	m_BlueButton = FALSE;
	SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton,  0 );
	m_GreyButton = TRUE;
	SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton,  0 );

	SendDlgItemMessage( IDC_NEW_CAMPAIGN,  BM_SETCHECK, m_NewButton,  0 );
	SendDlgItemMessage( IDC_LOAD_CAMPAIGN, BM_SETCHECK, m_LoadButton, 0 );
	SendDlgItemMessage( IDC_LAST_CAMPAIGN, BM_SETCHECK, m_LastButton, 0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectTanArmy() 
{
	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_TAN_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = TRUE;
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	if ( pMainFrame->IsMultiPlayer() )
	{
		m_BlueButton = TRUE;
		SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
		m_GreyButton = FALSE;
		SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
	}

	SendDlgItemMessage( IDC_NEW_CAMPAIGN,  BM_SETCHECK, m_NewButton,  0 );
	SendDlgItemMessage( IDC_LOAD_CAMPAIGN, BM_SETCHECK, m_LoadButton, 0 );
	SendDlgItemMessage( IDC_LAST_CAMPAIGN, BM_SETCHECK, m_LastButton, 0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectLastCampaign() 
{
	char**	pFileNames;

	// TODO: Add your control notification handler code here
	if ( gCWndCtlMaps == NULL )
	{
		gCWndCtlMaps = GetDlgItem( IDC_MULTI_CAMPAIGN_MAPS );
		if ( gCWndCtlMaps == NULL )
			return;
	}

	// get the last campaign
	pFileNames = m_FileNames;
    DLGEnumerateCampaigns( &gAMMapGuid, DLG_LAST_MAP, gCWndCtlMaps, pFileNames, &m_FirstSelection );
	DumpFileNames();
    gCWndCtlMaps->SetFocus();

    gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
    m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );

	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton,  0 );
	SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton,  0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectLoadCampaign() 
{
	char**	pFileNames;

	// TODO: Add your control notification handler code here
	if ( gCWndCtlMaps == NULL )
	{
		gCWndCtlMaps = GetDlgItem( IDC_MULTI_CAMPAIGN_MAPS );
		if ( gCWndCtlMaps == NULL )
			return;
	}

	// make a list of all saved campaigns
	pFileNames = (char**)m_FileNames;
	DLGEnumerateCampaigns( &gAMMapGuid, DLG_LOAD_MAP, gCWndCtlMaps, pFileNames, &m_FirstSelection );
	DumpFileNames();
    gCWndCtlMaps->SetFocus();

    gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
    m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );

	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton,  0 );
	SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton,  0 );
}

void CMultiPlyrCampaignSelectDlg::OnMultiPlyrCampaignSelectNewCampaign() 
{
	char**	pFileNames;

	// TODO: Add your control notification handler code here
	if ( gCWndCtlMaps == NULL )
	{
		gCWndCtlMaps = GetDlgItem( IDC_MULTI_CAMPAIGN_MAPS );
		if ( gCWndCtlMaps == NULL )
			return;
	}

	// make a list of all available campaigns
	pFileNames = (char**)m_FileNames;
    DLGEnumerateCampaigns( &gAMMapGuid, DLG_NEW_MAP, gCWndCtlMaps, pFileNames, &m_FirstSelection );
	DumpFileNames();
    gCWndCtlMaps->SetFocus();

    gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
    m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );

	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton,   0 );
	SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton,  0 );
	SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton,  0 );
}

/*
 * DumpFileNames
 *
 * Dump the list of filenames
 */
void CMultiPlyrCampaignSelectDlg::DumpFileNames( )
{
#ifdef DLG_FILENAME_DBG
	int		nIndex;

	nIndex = 0;
	for( nIndex=0; nIndex<DLG_MAX_FILES; ++nIndex )
	{
		if ( m_FileNames[ nIndex ] )
			TRACE( "%d: %s\n", nIndex, m_FileNames[ nIndex ] );
	}
#endif
}

int CHostSessionDlg::OnMultiPlyrSelectCampaignDialog() 
{
	int							result = IDCANCEL;
	CMultiPlyrCampaignSelectDlg multiPlyrDlg;
	CHostLobby hostLobbyDialog;
	// TODO: Add your command handler code here
	result = multiPlyrDlg.DoModal();
	if ( ( result == ID_FINISH ) && (gpComm->IsDPlay()) )	// was communication initialized correctly ?
	{
		// if so, launch game
		result = hostLobbyDialog.DoModal();
		if (result == IDOK) {
			TRACE("communications initialized...\n");
		pMainFrame->PostMessage( UM_TDG_LAUNCH, 0, 0 );
//		pMainFrame->StartGame();	// start the game
		}
	}
	else 
	{
		// otherwise, abort game
		TRACE("communications failed to initialized...\n");
		pMainFrame->PostMessage( UM_TDG_ABORT, 0, 0 );
	}

	return( result );
}

/////////////////////////////////////////////////////////////////////////////
// CMultiPlyrCampaignSelectDlg dialog

class CMultiPlyrCampaignSelectDlg : public CDialog
{
// Construction
public:
	CMultiPlyrCampaignSelectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	int		m_CampaignState;
	BOOL	m_NewButton;
	BOOL	m_LoadButton;
	BOOL	m_LastButton;

	int		m_ArmyState;
	BOOL	m_GreenButton;
	BOOL	m_TanButton;
	BOOL	m_BlueButton;
	BOOL	m_GreyButton;

	char*	m_FileNames[ DLG_MAX_FILES + 1 ];
	int		m_ItemIndex;
	BOOL	m_FirstSelection;

	HTREEITEM	m_hPrev; 
	HTREEITEM	m_hPrevRootItem; 
	HTREEITEM	m_hPrevLev2Item; 
	HTREEITEM	m_hPrevLev3Item;
 
	//{{AFX_DATA(CMultiPlyrCampaignSelectDlg)
	enum { IDD = IDD_SELECT_MULTI_CAMPAIGN };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMultiPlyrCampaignSelectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMultiPlyrCampaignSelectDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
	afx_msg void OnMultiPlyrCampaignSelectCancel();
	afx_msg void OnMultiPlyrCampaignSelectOK();
	afx_msg void OnMultiPlyrCampaignSelectBlueArmy();
	afx_msg void OnMultiPlyrCampaignSelectGreenArmy();
	afx_msg void OnMultiPlyrCampaignSelectGreyArmy();
	afx_msg void OnMultiPlyrCampaignSelectTanArmy();
	afx_msg void OnMultiPlyrCampaignSelectLastCampaign();
	afx_msg void OnMultiPlyrCampaignSelectLoadCampaign();
	afx_msg void OnMultiPlyrCampaignSelectNewCampaign();
	afx_msg void DumpFileNames();
	afx_msg void OnMultiPlyrCampaignSelectBack();
	afx_msg void OnMultiPlyrCampaignSelectNext();
	afx_msg void OnMultiPlyrCampaignSelectFinish();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSelectCampaignDlg dialog

class CSelectCampaignDlg : public CDialog
{
// Construction
public:
	CSelectCampaignDlg(CWnd* pParent = NULL);   // standard constructor

	int			m_CampaignID;
	int			m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	int			m_ItemIndex;
	BOOL		m_FirstSelection;
	HTREEITEM	m_hPrev; 
	HTREEITEM	m_hPrevRootItem; 
	HTREEITEM	m_hPrevLev2Item; 
	HTREEITEM	m_hPrevLev3Item;
 
// Dialog Data
	//{{AFX_DATA(CSelectCampaignDlg)
	enum { IDD = IDD_SELECT_CAMPAIGN };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectCampaignDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectCampaignDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectCampaignBack();
	afx_msg void OnSelectCampaignNext();
	afx_msg void OnSelectCampaignCancel();
	afx_msg void OnSelectCampaignSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSelectMission1Dlg dialog

class CSelectMission1Dlg : public CDialog
{
// Construction
public:
	CSelectMission1Dlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	LONG		m_MissionID;
	LONG		m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	LONG		m_ItemIndex;
	BOOL		m_FirstSelection;
	HTREEITEM	m_hPrev; 
	HTREEITEM	m_hPrevRootItem; 
	HTREEITEM	m_hPrevLev2Item; 
	HTREEITEM	m_hPrevLev3Item;
	HTREEITEM	m_htiVisible;		// points to a visible item in tree control
	CWnd*		m_CWndCtlMaps;
	LONG		m_ScenarioID;
 
	LONG*		m_pItemIndex;
	BOOL*		m_pFirstSelection;
	HTREEITEM*	m_phPrev; 
	HTREEITEM*	m_phPrevRootItem; 
	HTREEITEM*	m_phPrevLev2Item; 
	HTREEITEM*	m_phPrevLev3Item;
	HTREEITEM*	m_phtiVisible;		// points to a visible item in tree control
	CWnd*		m_pCWndCtlMaps;
 	LONG*		m_pScenarioID;

	//{{AFX_DATA(CSelectMission1Dlg)
	enum { IDD = IDD_MISSION_SELECT_1 };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectMission1Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectMission1Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectMission1Back();
	afx_msg void OnSelectMission1Cancel();
	afx_msg void OnSelectMission1Finish();
	afx_msg void OnSelectMission1Selchanged0();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSelectMission2Dlg dialog

class CSelectMission2Dlg : public CDialog
{
// Construction
public:
	CSelectMission2Dlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	LONG		m_MissionID;
	LONG		m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	LONG		m_ItemIndex[2];
	BOOL		m_FirstSelection[2];
	HTREEITEM	m_hPrev[2]; 
	HTREEITEM	m_hPrevRootItem[2]; 
	HTREEITEM	m_hPrevLev2Item[2]; 
	HTREEITEM	m_hPrevLev3Item[2];
	HTREEITEM	m_htiVisible[2];		// points to a visible item in tree control
	CWnd*		m_CWndCtlMaps[2];
	LONG		m_ScenarioID[2];
  
	LONG*		m_pItemIndex;
	BOOL*		m_pFirstSelection;
	HTREEITEM*	m_phPrev; 
	HTREEITEM*	m_phPrevRootItem; 
	HTREEITEM*	m_phPrevLev2Item; 
	HTREEITEM*	m_phPrevLev3Item;
	HTREEITEM*	m_phtiVisible;			// points to a visible item in tree control
	CWnd*		m_pCWndCtlMaps;
	LONG*		m_pScenarioID;

	int			m_WhichList;			// which list are we looking at

	//{{AFX_DATA(CSelectMission2Dlg)
	enum { IDD = IDD_MISSION_SELECT_2 };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectMission2Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectMission2Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectMission2Back();
	afx_msg void OnSelectMission2Cancel();
	afx_msg void OnSelectMission2Finish();
	afx_msg void OnSelectMission2Selchanged0();
	afx_msg void OnSelectMission2Selchanged1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSelectMission3Dlg dialog

class CSelectMission3Dlg : public CDialog
{
// Construction
public:
	CSelectMission3Dlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	LONG		m_MissionID;
	LONG		m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	LONG		m_ItemIndex[3];
	BOOL		m_FirstSelection[3];
	HTREEITEM	m_hPrev[3]; 
	HTREEITEM	m_hPrevRootItem[3]; 
	HTREEITEM	m_hPrevLev2Item[3]; 
	HTREEITEM	m_hPrevLev3Item[3];
	HTREEITEM	m_htiVisible[3];		// points to a visible item in tree control
	CWnd*		m_CWndCtlMaps[3];
 	LONG		m_ScenarioID[3];

	LONG*		m_pItemIndex;
	BOOL*		m_pFirstSelection;
	HTREEITEM*	m_phPrev; 
	HTREEITEM*	m_phPrevRootItem; 
	HTREEITEM*	m_phPrevLev2Item; 
	HTREEITEM*	m_phPrevLev3Item;
	HTREEITEM*	m_phtiVisible;			// points to a visible item in tree control
	CWnd*		m_pCWndCtlMaps;
	LONG*		m_pScenarioID;

	int			m_WhichList;			// which list are we looking at

	//{{AFX_DATA(CSelectMission3Dlg)
	enum { IDD = IDD_MISSION_SELECT_3 };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectMission3Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectMission3Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectMission3Back();
	afx_msg void OnSelectMission3Cancel();
	afx_msg void OnSelectMission3Finish();
	afx_msg void OnSelectMission3Selchanged0();
	afx_msg void OnSelectMission3Selchanged1();
	afx_msg void OnSelectMission3Selchanged2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSelectMission4Dlg dialog

class CSelectMission4Dlg : public CDialog
{
// Construction
public:
	CSelectMission4Dlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	LONG		m_MissionID;
	LONG		m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	LONG		m_ItemIndex[4];
	BOOL		m_FirstSelection[4];
	HTREEITEM	m_hPrev[4]; 
	HTREEITEM	m_hPrevRootItem[4]; 
	HTREEITEM	m_hPrevLev2Item[4]; 
	HTREEITEM	m_hPrevLev3Item[4];
	HTREEITEM	m_htiVisible[4];		// points to a visible item in tree control
	CWnd*		m_CWndCtlMaps[4];
	LONG		m_ScenarioID[4];
 
	LONG*		m_pItemIndex;
	BOOL*		m_pFirstSelection;
	HTREEITEM*	m_phPrev; 
	HTREEITEM*	m_phPrevRootItem; 
	HTREEITEM*	m_phPrevLev2Item; 
	HTREEITEM*	m_phPrevLev3Item;
	HTREEITEM*	m_phtiVisible;			// points to a visible item in tree control
	CWnd*		m_pCWndCtlMaps;
	LONG*		m_pScenarioID;

	int			m_WhichList;			// which list are we looking at

	//{{AFX_DATA(CSelectMission4Dlg)
	enum { IDD = IDD_MISSION_SELECT_4 };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectMission4Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectMission4Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectMission4Back();
	afx_msg void OnSelectMission4Cancel();
	afx_msg void OnSelectMission4Finish();
	afx_msg void OnSelectMission4Selchanged0();
	afx_msg void OnSelectMission4Selchanged1();
	afx_msg void OnSelectMission4Selchanged2();
	afx_msg void OnSelectMission4Selchanged3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSelectMissionMoreDlg dialog

class CSelectMissionMoreDlg : public CDialog
{
// Construction
public:
	CSelectMissionMoreDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	LONG		m_MissionID;
	LONG		m_ScenarioIndex;
	char*		m_FileNames[ DLG_MAX_FILES + 1 ];

	LONG		m_ItemIndex[4];
	BOOL		m_FirstSelection[4];
	HTREEITEM	m_hPrev[4]; 
	HTREEITEM	m_hPrevRootItem[4]; 
	HTREEITEM	m_hPrevLev2Item[4]; 
	HTREEITEM	m_hPrevLev3Item[4];
	HTREEITEM	m_htiVisible[4];		// points to a visible item in tree control
	CWnd*		m_CWndCtlMaps[4];
	LONG		m_ScenarioID[4];
 
	LONG*		m_pItemIndex;
	BOOL*		m_pFirstSelection;
	HTREEITEM*	m_phPrev; 
	HTREEITEM*	m_phPrevRootItem; 
	HTREEITEM*	m_phPrevLev2Item; 
	HTREEITEM*	m_phPrevLev3Item;
	HTREEITEM*	m_phtiVisible;			// points to a visible item in tree control
	CWnd*		m_pCWndCtlMaps;
	LONG*		m_pScenarioID;

	int			m_WhichList;			// which list are we looking at

	//{{AFX_DATA(CSelectMissionMoreDlg)
	enum { IDD = IDD_MISSION_SELECT_MORE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectMissionMoreDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectMissionMoreDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelectMissionMoreBack();
	afx_msg void OnSelectMissionMoreMore();
	afx_msg void OnSelectMissionMoreCancel();
	afx_msg void OnSelectMissionMoreFinish();
	afx_msg void OnSelectMissionMoreSelchanged0();
	afx_msg void OnSelectMissionMoreSelchanged1();
	afx_msg void OnSelectMissionMoreSelchanged2();
	afx_msg void OnSelectMissionMoreSelchanged3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

int CHostSessionDlg::OnSelectCampaignDialog() 
{
	int					result  = IDCANCEL;
	CSelectCampaignDlg	selectCampaignDlg;

	// TODO: Add your command handler code here
	result = selectCampaignDlg.DoModal();
	if ( (result == ID_FINISH) && (gpComm->IsDPlay()) )	// was communication initialized correctly ?
	{
		// if so, choose the actual mission
		TRACE("communications initialized...\n");
		pMainFrame->PostMessage( UM_TDG_LAUNCH, 0, 0 );

//		pMainFrame->StartGame();
	}
	else
	{
		// otherwise, abort game
		TRACE("communications failed to initialized...\n");
		pMainFrame->PostMessage( UM_TDG_ABORT, 0, 0 );
	}

	return( result );
}

int CMainFrame::OnMissionSelect1Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission1Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CMainFrame::OnMissionSelect2Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission2Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CMainFrame::OnMissionSelect3Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission3Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CMainFrame::OnMissionSelect4Dialog() 
{
	int				   result = IDCANCEL;
	CSelectMission4Dlg missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

int CMainFrame::OnMissionSelectMoreDialog() 
{
	int						result = IDCANCEL;
	CSelectMissionMoreDlg	missionSelectDlg;

	// TODO: Add your command handler code here
	result = missionSelectDlg.DoModal();
	if ( result == ID_FINISH )
		pMainFrame->StartGame();	// start the game

	return( result );
}

/////////////////////////////////////////////////////////////////////////////
// CMultiPlyrCampaignSelectDlg dialog


CMultiPlyrCampaignSelectDlg::CMultiPlyrCampaignSelectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMultiPlyrCampaignSelectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMultiPlyrCampaignSelectDlg)
		// NOTE: the ClassWizard will add member initialization here
	m_ItemIndex      = 0;
	m_CampaignState  = DLG_NEW_MAP;			// initialize to a new game
	m_NewButton      = DLG_BUTTON_ON;		// new game CHECKED
	m_LoadButton     = DLG_BUTTON_OFF;		// load game UNCHECKED
	m_LastButton     = DLG_BUTTON_OFF;		// last game UNCHECKED
	m_ArmyState      = DLG_GREEN_BUTTON;		// initialize to a green army
	m_GreenButton    = DLG_BUTTON_ON;		// green army CHECKED
	m_TanButton      = DLG_BUTTON_OFF;		// tan army UNCHECKED
	m_BlueButton     = DLG_BUTTON_OFF;		// blue army UNCHECKED
	m_GreyButton     = DLG_BUTTON_OFF;		// grey army UNCHECKED
	m_hPrev          = NULL; 
	m_hPrevRootItem  = NULL; 
	m_hPrevLev2Item  = NULL; 
	m_hPrevLev3Item  = NULL;
	m_FirstSelection = FALSE;
	//}}AFX_DATA_INIT
}


void CMultiPlyrCampaignSelectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMultiPlyrCampaignSelectDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMultiPlyrCampaignSelectDlg, CDialog)
	//{{AFX_MSG_MAP(CMultiPlyrCampaignSelectDlg)
	ON_BN_CLICKED(IDCANCEL, OnMultiPlyrCampaignSelectCancel)
	ON_BN_CLICKED(IDC_BLUE_ARMY, OnMultiPlyrCampaignSelectBlueArmy)
	ON_BN_CLICKED(IDC_GREEN_ARMY, OnMultiPlyrCampaignSelectGreenArmy)
	ON_BN_CLICKED(IDC_GREY_ARMY, OnMultiPlyrCampaignSelectGreyArmy)
	ON_BN_CLICKED(IDC_TAN_ARMY, OnMultiPlyrCampaignSelectTanArmy)
	ON_BN_CLICKED(IDC_LAST_CAMPAIGN, OnMultiPlyrCampaignSelectLastCampaign)
	ON_BN_CLICKED(IDC_LOAD_CAMPAIGN, OnMultiPlyrCampaignSelectLoadCampaign)
	ON_BN_CLICKED(IDC_NEW_CAMPAIGN, OnMultiPlyrCampaignSelectNewCampaign)
	ON_BN_CLICKED(ID_BACK, OnMultiPlyrCampaignSelectBack)
	ON_BN_CLICKED(ID_FINISH, OnMultiPlyrCampaignSelectFinish)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCampaignDlg dialog

CSelectCampaignDlg::CSelectCampaignDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSelectCampaignDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectCampaignDlg)
		// NOTE: the ClassWizard will add member initialization here
	m_CampaignID     = -1;
	m_ScenarioIndex  = 0;
	m_hPrev          = NULL; 
	m_hPrevRootItem  = NULL; 
	m_hPrevLev2Item  = NULL; 
	m_hPrevLev3Item  = NULL;
	m_FirstSelection = FALSE;
	//}}AFX_DATA_INIT
}


void CSelectCampaignDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectCampaignDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectCampaignDlg, CDialog)
	//{{AFX_MSG_MAP(CSelectCampaignDlg)
	ON_BN_CLICKED(ID_BACK, OnSelectCampaignBack)
	ON_BN_CLICKED(ID_NEXT, OnSelectCampaignNext)
	ON_BN_CLICKED(IDCANCEL, OnSelectCampaignCancel)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CAMPAIGN_MAPS, OnSelectCampaignSelchanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCampaignDlg message handlers

BOOL CSelectCampaignDlg::OnInitDialog() 
{
//	HWND			hTreeCtl;
	CAMPAIGNREF*	pCampaignRef;
	char**			pFileNames;
	int				nIndex;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	ghAMPrev         = (HTREEITEM) TVI_FIRST; 
	ghAMPrevRootItem = NULL; 
	ghAMPrevLev2Item = NULL; 
	ghAMPrevLev3Item = NULL; 

    // access the treeview for the campaign maps.
	gCWndCtlMaps = GetDlgItem( IDC_CAMPAIGN_MAPS );
	if (gCWndCtlMaps == NULL)
		return(TRUE);

	// clear the filenames list and initialize
	for ( nIndex=0;nIndex<DLG_MAX_FILES; ++nIndex )
		m_FileNames[ nIndex ] = NULL;
	pFileNames = m_FileNames;
    DLGEnumerateCampaigns( &gAMMapGuid, DLG_CAMPAIGN_MAP, (LPVOID)gCWndCtlMaps, pFileNames, &m_FirstSelection );

	// now set the IDs and the starting index
	pCampaignRef  = g_Campaigns[ 0 ];
	m_CampaignID  = pCampaignRef->nCampaignID;
	gAMCampaignID = m_CampaignID;

	m_ItemIndex = 0;
	gCWndCtlMaps->SendMessage( LB_SETCURSEL, m_ItemIndex, 0 );
    m_ItemIndex = gCWndCtlMaps->SendMessage( LB_GETCURSEL, 0, 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectCampaignDlg::OnSelectCampaignBack() 
{
	// TODO: Add your control notification handler code here
    DLGReleaseCampaignData( m_FileNames );
	CDialog::OnCancel();
	CDialog::EndDialog( ID_BACK );
}

void CSelectCampaignDlg::OnSelectCampaignNext() 
{
	// TODO: Add your control notification handler code here
#if 0
	LRESULT			nID;
	CWnd*			CWndCtl;

	// TODO: Add your control notification handler code here
	CWndCtl = GetDlgItem( IDC_CAMPAIGN_MAPS );
	if ( CWndCtl == NULL )
		goto hadError;

	m_ItemIndex = CWndCtl->SendMessage( LB_GETCURSEL, 0, 0 );
    if (m_ItemIndex != LB_ERR)
    {
		// this had better be a CAMPAIGN ID
		g_CampaignIndex = m_ItemIndex;

        nID = (int) CWndCtl->SendMessage( LB_GETITEMDATA, m_ItemIndex, 0 );
		if ( nID <= DLG_CAMPAIGN_ID_BASE )
		{
			ShowError( IDS_NEED_CAMPAIGN );
			goto hadError;
		}
		gAMCampaignID      = (int)nID;
		gpGame->CampaignID = 0;
    }
#else
		gAMCampaignID      = m_CampaignID;
		gpGame->CampaignID = 0;
#endif

    DLGReleaseCampaignData( m_FileNames );
	CDialog::OnOK();
	CDialog::EndDialog( ID_NEXT );
	return;
#if 0
hadError:
	CDialog::OnOK();
	CDialog::EndDialog( IDOK );
#endif
}

void CSelectCampaignDlg::OnSelectCampaignCancel() 
{
	// TODO: Add your control notification handler code here
    DLGReleaseCampaignData( m_FileNames );
	gpComm->Release();
	CDialog::OnCancel();
}

void CSelectCampaignDlg::OnSelectCampaignSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*	pNMTreeView = (NM_TREEVIEW*)pNMHDR;
//	HTREEITEM		hTreeItem   = pNMTreeView->itemNew.hItem;
	LONG			nData       = pNMTreeView->itemNew.lParam;

	// TODO: Add your control notification handler code here
    // access the treeview for the campaign maps.
	if ( nData >= DLG_CAMPAIGN_ID_BASE )
		m_CampaignID = nData;

	// advance the selection to the first item in expamded list
	
	*pResult = 0;
}

int CMainFrame::OnMissionSelectDialog() 
{
	int		nNumberScenarios = g_NumberScenarios;
	int		result           = IDCANCEL;
	BOOL	done             = FALSE;

	// TODO: Add your command handler code here
	while ( !done )
	{
		switch( nNumberScenarios )
		{
		case 0:
			ShowError( IDS_NO_SCENARIOS );
			goto exit;
			break;
		case 1:
			result = OnMissionSelect1Dialog();
			break;
		case 2:
			result = OnMissionSelect2Dialog();
			break;
		case 3:
			result = OnMissionSelect3Dialog();
			break;
		case 4:
			result = OnMissionSelect4Dialog();
			break;
		default:
			result = OnMissionSelectMoreDialog();
			break;
		}

		if ( (result != ID_BACK) && (result != ID_MORE) )
			done = TRUE;
		else
		{
			if ( result == ID_MORE )
			{
				g_ScenarioIndex  += 4;
				nNumberScenarios -= 4;
			}

			if ( result == ID_BACK )
			{
				if ( g_ScenarioIndex )
				{
					g_ScenarioIndex  -= 4;
					nNumberScenarios += 4;
				}
				else
					done = TRUE;
			}
		}
	}
exit:
	return( result );
}

/////////////////////////////////////////////////////////////////////////////
// CGameOptionsDlg dialog

/*
CGameOptionsDlg::CGameOptionsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGameOptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGameOptionsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_SfxOnOff  = DLGSfxOnOff;
	m_SfxVolume = DLGSfxVolume;

	m_VoiceOnOff  = DLGVoiceOnOff;
	m_VoiceVolume = DLGVoiceVolume;

	m_MusicOnOff  = DLGMusicOnOff;
	m_MusicVolume = DLGMusicVolume;
}


void CGameOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGameOptionsDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BOOL CGameOptionsDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	// TODO: Add your specialized code here and/or call the base class
    switch (((NMHDR FAR *) lParam)->code) 
    {
    case PSN_SETACTIVE:
		break;
	}
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

BEGIN_MESSAGE_MAP(CGameOptionsDlg, CDialog)
	//{{AFX_MSG_MAP(CGameOptionsDlg)
	ON_NOTIFY(NM_CLICK, IDC_SFX_VOLUME_SLIDER, OnSfxVolumeClick)
	ON_BN_CLICKED(IDC_SFX_OPTION_OFF_BUTTON, OnSfxOptionOff)
	ON_BN_CLICKED(IDC_SFX_OPTION_ON_BUTTON, OnSfxOptionOn)
	ON_NOTIFY(NM_CLICK, IDC_VOICE_VOLUME_SLIDER, OnVoiceVolumeClick)
	ON_BN_CLICKED(IDC_VOICE_OPTION_OFF_BUTTON, OnVoiceOptionOff)
	ON_BN_CLICKED(IDC_VOICE_OPTION_ON_BUTTON, OnVoiceOptionOn)
	ON_NOTIFY(NM_CLICK, IDC_MUSIC_VOLUME_SLIDER, OnMusicVolumeClick)
	ON_BN_CLICKED(IDC_MUSIC_OPTION_OFF_BUTTON, OnMusicOptionOff)
	ON_BN_CLICKED(IDC_MUSIC_OPTION_ON_BUTTON, OnMusicOptionOn)
	ON_BN_CLICKED(IDCANCEL, OnGameOptionsCancel)
	ON_BN_CLICKED(IDOK, OnGameOptionsOK)
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
*/

/////////////////////////////////////////////////////////////////////////////
// CGameOptionsDlg message handlers

/*
BOOL CGameOptionsDlg::OnInitDialog() 
{
	BOOL			sfxOn;
	BOOL			sfxOff;
	BOOL			voiceOn;
	BOOL			voiceOff;
	BOOL			musicOn;
	BOOL			musicOff;
	CSliderCtrl*	Cslider;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here 
	m_SfxVolume      = audioGetMasterVolume( SND_SFX_FLAG );
	m_VoiceVolume    = audioGetMasterVolume( SND_VOICE_FLAG );;
	m_MusicVolume    = audioGetMasterVolume( SND_MUSIC_FLAG );;

	sfxOn    = m_SfxOnOff;
	sfxOff   = ((m_SfxOnOff) ? (FALSE) : (TRUE));
	voiceOn  = m_VoiceOnOff;
	voiceOff = ((m_VoiceOnOff) ? (FALSE) : (TRUE));
	musicOn  = m_MusicOnOff;
	musicOff = ((m_MusicOnOff) ? (FALSE) : (TRUE));;
	SendDlgItemMessage( IDC_SFX_OPTION_ON_BUTTON,    BM_SETCHECK, sfxOn, 0 );
	SendDlgItemMessage( IDC_SFX_OPTION_OFF_BUTTON,   BM_SETCHECK, sfxOff, 0 );
	SendDlgItemMessage( IDC_VOICE_OPTION_ON_BUTTON,  BM_SETCHECK, voiceOn, 0 );
	SendDlgItemMessage( IDC_VOICE_OPTION_OFF_BUTTON, BM_SETCHECK, voiceOff, 0 );
	SendDlgItemMessage( IDC_MUSIC_OPTION_ON_BUTTON,  BM_SETCHECK, musicOn, 0 );
	SendDlgItemMessage( IDC_MUSIC_OPTION_OFF_BUTTON, BM_SETCHECK, musicOff, 0 );

    // setup title fonts
    SendDlgItemMessage( IDC_SFX_VOLUME_0,	    WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_SFX_VOLUME_50,	    WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_SFX_VOLUME_100,	    WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_VOICE_OPTION_TITLE, WM_SETFONT, (WPARAM)ghTitleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_VOICE_VOLUME_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_VOICE_VOLUME_0,	    WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_VOICE_VOLUME_50,	WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_VOICE_VOLUME_100,	WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MUSIC_OPTION_TITLE, WM_SETFONT, (WPARAM)ghTitleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MUSIC_VOLUME_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MUSIC_VOLUME_0,	    WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MUSIC_VOLUME_50,	WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MUSIC_VOLUME_100,	WM_SETFONT, (WPARAM)ghScaleFont,   MAKELPARAM(TRUE,0) );

	// initialize the slider bars
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_SFX_VOLUME_SLIDER );
	if (Cslider == NULL)
		goto exit;
	Cslider->ClearTics();				// clear existing tic mark designators
	Cslider->SetRange( 0, 100, TRUE );	// set the slider range from 0 to 100
	Cslider->SetTicFreq( 5 );			// set the slider tic mark frequency
	Cslider->SetPos( m_SfxVolume );		// set the slider value

	Cslider = (CSliderCtrl*)GetDlgItem( IDC_VOICE_VOLUME_SLIDER );
	if (Cslider == NULL)
		goto exit;
	Cslider->ClearTics();				// clear existing tic mark designators
	Cslider->SetRange( 0, 100, TRUE );	// set the slider range from 0 to 100
	Cslider->SetTicFreq( 5 );			// set the slider tic mark frequency
	Cslider->SetPos( m_VoiceVolume );		// set the slider value

	Cslider = (CSliderCtrl*)GetDlgItem( IDC_MUSIC_VOLUME_SLIDER );
	if (Cslider == NULL)
		goto exit;
	Cslider->ClearTics();				// clear existing tic mark designators
	Cslider->SetRange( 0, 100, TRUE );	// set the slider range from 0 to 100
	Cslider->SetTicFreq( 5 );			// set the slider tic mark frequency
	Cslider->SetPos( m_MusicVolume );		// set the slider value

exit:
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGameOptionsDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	int				nCtrlID;
	CSliderCtrl*	Cslider = (CSliderCtrl*)pScrollBar;

	// TODO: Add your message handler code here and/or call default
	switch( nSBCode )
	{
	case TB_BOTTOM:		//	VK_END
		break;
	case TB_ENDTRACK:	//	WM_KEYUP (the user released a key that sent a relevant virtual-key code)
		break;
	case TB_LINEDOWN:	//	VK_RIGHT or VK_DOWN
		break;
	case TB_LINEUP:		//	VK_LEFT or VK_UP
		break;
	case TB_PAGEDOWN:	//	VK_NEXT (the user clicked the channel below or to the right of the slider)
		break;
	case TB_PAGEUP:		//	VK_PRIOR (the user clicked the channel above or to the left of the slider)
		break;
	case TB_THUMBPOSITION:	//	WM_LBUTTONUP following a TB_THUMBTRACK notification message
		nCtrlID   = DLGfindEditCtrl( Cslider );
		if ( nCtrlID )
			DLGSetVolumeMember( Cslider, nCtrlID, nPos );
		break;
	case TB_THUMBTRACK:	//	Slider movement (the user dragged the slider)
		break;
	case TB_TOP:		//	VK_HOME
		break;
	}	
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}


void CGameOptionsDlg::OnSfxVolumeClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	int				nPercent;
	CSliderCtrl*	Cslider;

	// TODO: Add your control notification handler code here
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_SFX_VOLUME_SLIDER );
	if ( Cslider )
	{
		nPercent = Cslider->GetPos();
		SetSfxVolume( nPercent );
//		audioSetMasterVolume( SND_SFX_FLAG, (LONG)nPercent );
	}
	*pResult = 0;
}

void CGameOptionsDlg::OnSfxOptionOff() 
{
	// TODO: Add your control notification handler code here
	m_SfxOnOff = DLG_BUTTON_OFF;
}

void CGameOptionsDlg::OnSfxOptionOn() 
{
	// TODO: Add your control notification handler code here
	m_SfxOnOff  = DLG_BUTTON_ON;
}

void CGameOptionsDlg::OnVoiceVolumeClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	int				nPercent;
	CSliderCtrl*	Cslider;

	// TODO: Add your control notification handler code here
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_VOICE_VOLUME_SLIDER );
	if ( Cslider )
	{
		nPercent = Cslider->GetPos();
		SetSfxVolume( nPercent );
//		audioSetMasterVolume( SND_VOICE_FLAG, (LONG)nPercent );
	}
	*pResult = 0;
}

void CGameOptionsDlg::OnVoiceOptionOff() 
{
	// TODO: Add your control notification handler code here
	m_VoiceOnOff  = DLG_BUTTON_OFF;
}

void CGameOptionsDlg::OnVoiceOptionOn() 
{
	// TODO: Add your control notification handler code here
	m_VoiceOnOff  = DLG_BUTTON_ON;
}

void CGameOptionsDlg::OnMusicVolumeClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	int				nPercent;
	CSliderCtrl*	Cslider;

	// TODO: Add your control notification handler code here
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_MUSIC_VOLUME_SLIDER );
	if ( Cslider )
	{
		nPercent = Cslider->GetPos();
		SetSfxVolume( nPercent );
//		audioSetMasterVolume( SND_MUSIC_FLAG, (LONG)nPercent );
	}
	*pResult = 0;
}

void CGameOptionsDlg::OnMusicOptionOff() 
{
	// TODO: Add your control notification handler code here
	m_MusicOnOff = DLG_BUTTON_OFF;
}

void CGameOptionsDlg::OnMusicOptionOn() 
{
	// TODO: Add your control notification handler code here
	m_MusicOnOff = DLG_BUTTON_ON;
}

void CGameOptionsDlg::OnGameOptionsCancel() 
{
	BOOL			sfxOn;
	BOOL			sfxOff;
	BOOL			voiceOn;
	BOOL			voiceOff;
	BOOL			musicOn;
	BOOL			musicOff;
	CSliderCtrl*	Cslider;

	// TODO: Add extra initialization here 
	m_SfxVolume      = audioGetMasterVolume( SND_SFX_FLAG );
	m_VoiceVolume    = audioGetMasterVolume( SND_VOICE_FLAG );;
	m_MusicVolume    = audioGetMasterVolume( SND_MUSIC_FLAG );;

	sfxOn    = m_SfxOnOff;
	sfxOff   = ((m_SfxOnOff) ? (FALSE) : (TRUE));
	voiceOn  = m_VoiceOnOff;
	voiceOff = ((m_VoiceOnOff) ? (FALSE) : (TRUE));
	musicOn  = m_MusicOnOff;
	musicOff = ((m_MusicOnOff) ? (FALSE) : (TRUE));;
	SendDlgItemMessage( IDC_SFX_OPTION_ON_BUTTON,    BM_SETCHECK, sfxOn, 0 );
	SendDlgItemMessage( IDC_SFX_OPTION_OFF_BUTTON,   BM_SETCHECK, sfxOff, 0 );
	SendDlgItemMessage( IDC_VOICE_OPTION_ON_BUTTON,  BM_SETCHECK, voiceOn, 0 );
	SendDlgItemMessage( IDC_VOICE_OPTION_OFF_BUTTON, BM_SETCHECK, voiceOff, 0 );
	SendDlgItemMessage( IDC_MUSIC_OPTION_ON_BUTTON,  BM_SETCHECK, musicOn, 0 );
	SendDlgItemMessage( IDC_MUSIC_OPTION_OFF_BUTTON, BM_SETCHECK, musicOff, 0 );

	Cslider = (CSliderCtrl*)GetDlgItem( IDC_SFX_VOLUME_SLIDER );
	if ( Cslider )
		Cslider->SetPos( m_SfxVolume );
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_VOICE_VOLUME_SLIDER );
	if ( Cslider )
		Cslider->SetPos( m_VoiceVolume );
	Cslider = (CSliderCtrl*)GetDlgItem( IDC_MUSIC_VOLUME_SLIDER );
	if ( Cslider )
		Cslider->SetPos( m_MusicVolume );

	CDialog::OnCancel();
}

void CGameOptionsDlg::OnGameOptionsOK() 
{
	// TODO: Add your control notification handler code here
	if ( m_SfxOnOff )
		audioSfxOn();
	else
		audioSfxOff();
	DLGSfxOnOff = m_SfxOnOff;

	if ( m_VoiceOnOff )
		audioVoiceOn();
	else
		audioVoiceOff();
	DLGSfxOnOff = m_VoiceOnOff;

	if ( m_MusicOnOff )
		audioMusicOn();
	else
		audioMusicOff();
	DLGSfxOnOff = m_MusicOnOff;

	audioSetMasterVolume( SND_SFX_FLAG,   (LONG)m_SfxVolume );
	DLGSfxVolume = (LONG)m_SfxVolume;
	audioSetMasterVolume( SND_VOICE_FLAG, (LONG)m_VoiceVolume );
	DLGVoiceVolume = (LONG)m_VoiceVolume;
	audioSetMasterVolume( SND_MUSIC_FLAG, (LONG)m_MusicVolume );
	DLGMusicVolume = (LONG)m_MusicVolume;

	CDialog::OnOK();
}

void CGameOptionsDlg::SetSfxVolume( int nPercent ) 
{
	// TODO: Add your control notification handler code here
	m_SfxVolume  = nPercent;
}

void CGameOptionsDlg::SetVoiceVolume( int nPercent ) 
{
	// TODO: Add your control notification handler code here
	m_VoiceVolume  = nPercent;
}

void CGameOptionsDlg::SetMusicVolume( int nPercent ) 
{
	// TODO: Add your control notification handler code here
	m_MusicVolume  = nPercent;
}

/////////////////////////////////////////////////////////////////////////////
// CGameStartDlg dialog


CGameStartDlg::CGameStartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGameStartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGameStartDlg)
		// NOTE: the ClassWizard will add member initialization here
	m_OnePlayerButton      = DLG_BUTTON_OFF;
	m_MultiPlayerButton    = DLG_BUTTON_OFF;
	m_OptionsButton        = DLG_BUTTON_OFF;
	m_QuitButton           = DLG_BUTTON_OFF;
	m_FirstButton          = TRUE;
	//}}AFX_DATA_INIT
}


void CGameStartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGameStartDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGameStartDlg, CDialog)
	//{{AFX_MSG_MAP(CGameStartDlg)
	ON_BN_CLICKED(IDC_ONE_PLAYER_BUTTON, OnGameStartOnePlayerButton)
	ON_BN_CLICKED(IDC_MULTI_PLAYER_BUTTON, OnGameStartMultiPlayerButton)
	ON_BN_CLICKED(IDC_OPTIONS_BUTTON, OnGameStartOptionsButton)
	ON_BN_CLICKED(IDC_QUIT_BUTTON, OnGameStartQuitButton)
	ON_BN_DOUBLECLICKED(IDC_ONE_PLAYER_BUTTON, OnGameStartOnePlayerButton)
	ON_BN_DOUBLECLICKED(IDC_MULTI_PLAYER_BUTTON, OnGameStartMultiPlayerButton)
	ON_BN_DOUBLECLICKED(IDC_OPTIONS_BUTTON, OnGameStartOptionsButton)
	ON_BN_DOUBLECLICKED(IDC_QUIT_BUTTON, OnGameStartQuitButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGameStartDlg message handlers

BOOL CGameStartDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
#if 0
	if ( gpComm->IsConnected() == FALSE )
	{
		m_OnePlayerButton   = DLG_BUTTON_OFF;
		m_MultiPlayerButton = DLG_BUTTON_GREY;
	}
	else
	{
		m_OnePlayerButton   = DLG_BUTTON_GREY;
		m_MultiPlayerButton = DLG_BUTTON_OFF;
	}
#else
	m_OnePlayerButton   = DLG_BUTTON_OFF;
	m_MultiPlayerButton = DLG_BUTTON_OFF;
#endif
	m_OptionsButton     = DLG_BUTTON_OFF;
	m_QuitButton        = DLG_BUTTON_OFF;

#if 0
	SendDlgItemMessage( IDC_ONE_PLAYER_BUTTON,   BM_SETCHECK, m_OnePlayerButton, 0 );
	SendDlgItemMessage( IDC_MULTI_PLAYER_BUTTON, BM_SETCHECK, m_MultiPlayerButton, 0 );
	SendDlgItemMessage( IDC_OPTIONS_BUTTON,		 BM_SETCHECK, m_OptionsButton, 0 );
	SendDlgItemMessage( IDC_QUIT_BUTTON,         BM_SETCHECK, m_QuitButton, 0 );
#endif

    // setup title fonts
    SendDlgItemMessage( IDC_ONE_PLAYER_BUTTON,   WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_MULTI_PLAYER_BUTTON, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_OPTIONS_BUTTON,      WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );
    SendDlgItemMessage( IDC_QUIT_BUTTON,         WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0) );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGameStartDlg::OnGameStartOnePlayerButton() 
{
	// TODO: Add your control notification handler code here
	m_OnePlayerButton      = DLG_BUTTON_ON;
	m_MultiPlayerButton    = DLG_BUTTON_OFF;
	m_OptionsButton        = DLG_BUTTON_OFF;
	m_QuitButton           = DLG_BUTTON_OFF;

	if ( !m_FirstButton )
	{
		if ( gpComm->m_hRegKey == COMM_NULL_KEY )
		{
			// open/create duel registry key 
			RegCreateKeyEx( HKEY_CURRENT_USER,
							ARMYMEN_KEY,
							0,
							NULL,                   
							REG_OPTION_NON_VOLATILE,
							KEY_ALL_ACCESS,
							NULL,
							&(gpComm->m_hRegKey),
							&(gpComm->m_dwRegDisp)
							);
		}
		CDialog::OnOK();
		CDialog::EndDialog( IDC_ONE_PLAYER_BUTTON );
	}
	m_FirstButton = FALSE;
}

void CGameStartDlg::OnGameStartMultiPlayerButton() 
{
	// TODO: Add your control notification handler code here
//	if ( gpComm->IsConnected() )
//	{
		m_OnePlayerButton      = DLG_BUTTON_OFF;
		m_MultiPlayerButton    = DLG_BUTTON_ON;
		m_OptionsButton        = DLG_BUTTON_OFF;
		m_QuitButton           = DLG_BUTTON_OFF;
//	}

	if ( !m_FirstButton )
	{
		if ( gpComm->m_hRegKey == COMM_NULL_KEY )
		{
			// open/create duel registry key 
			RegCreateKeyEx( HKEY_CURRENT_USER,
							ARMYMEN_KEY,
							0,
							NULL,                   
							REG_OPTION_NON_VOLATILE,
							KEY_ALL_ACCESS,
							NULL,
							&(gpComm->m_hRegKey),
							&(gpComm->m_dwRegDisp)
							);
		}
		CDialog::OnOK();
		CDialog::EndDialog( IDC_MULTI_PLAYER_BUTTON );
	}
	m_FirstButton = FALSE;
}

void CGameStartDlg::OnGameStartOptionsButton() 
{
	// TODO: Add your control notification handler code here
	m_OnePlayerButton      = DLG_BUTTON_OFF;
	m_MultiPlayerButton    = DLG_BUTTON_OFF;
	m_OptionsButton        = DLG_BUTTON_ON;
	m_QuitButton           = DLG_BUTTON_OFF;

	if ( !m_FirstButton )
	{
		CDialog::OnOK();
		CDialog::EndDialog( IDC_OPTIONS_BUTTON );
	}
	m_FirstButton = FALSE;
}

void CGameStartDlg::OnGameStartQuitButton() 
{
	// TODO: Add your control notification handler code here
	m_OnePlayerButton      = DLG_BUTTON_OFF;
	m_MultiPlayerButton    = DLG_BUTTON_OFF;
	m_OptionsButton        = DLG_BUTTON_OFF;
	m_QuitButton           = DLG_BUTTON_ON;

	if ( !m_FirstButton )
	{
		CDialog::OnCancel();
		CDialog::EndDialog( IDC_QUIT_BUTTON );
	}
	m_FirstButton = FALSE;
}

/*
//	emulate joystick with keyboard
void FakeJoyInput( void )
{
	int joyradius;
	int curspeed = 0;
	int curdirection;

	if (sargestop)						//stops moving when you stop pressing the key
	{
		if (user_action & DO_EXTRASPEED)
			joyradius=701;
		else 
			joyradius=401;

		if (user_action & DO_ACCELERATE)
			joydata.y=-joyradius;

		if (user_action & DO_DECELERATE)
			joydata.y=joyradius;

		if (user_action & DO_TURN_RIGHT)
			joydata.x=joyradius;

		if (user_action & DO_TURN_LEFT)
			joydata.x=-joyradius;

		if (user_action & DO_FIRE)
			joydata.buttonpressed[0] = 1;
	}
	else
	{
		if (user_action & (DO_ACCELERATE|DO_DECELERATE|DO_TURN_RIGHT|DO_TURN_LEFT))
		{
			if (curspeed==0)
				curspeed=1;

			if (user_action & DO_EXTRASPEED)
				curspeed=2;

			if (user_action & DO_ACCELERATE)
			{
				if (user_action & DO_TURN_RIGHT)
					curdirection=7;
				else if (user_action & DO_TURN_LEFT)
					curdirection=1;
				else
					curdirection=0;
			}
			else if (user_action & DO_DECELERATE)
			{
				if (user_action & DO_TURN_RIGHT)
					curdirection=5;
				else if (user_action & DO_TURN_LEFT)
					curdirection=3;
				else
					curdirection=4;
			}
			else if (user_action & DO_TURN_RIGHT)
				curdirection=6;
			else
				curdirection=2;
		}

		if (user_action & DO_STOP)
		{
			user_action ^= DO_STOP;
			if (curspeed)
				curspeed--;
		}

		switch(curspeed)
		{
		case 0:
			joydata.x=0;
			joydata.y=0;
			joyradius=0;
		break;

		case 1:
			joyradius=401;
			break;

		case 2:
			joyradius=701;
			break;
		}

		if (joyradius)
		{
			switch(curdirection)
			{
			case 0:
				joydata.x=0;
				joydata.y=-joyradius;
				break;
			case 1:
				joydata.x=-joyradius;
				joydata.y=-joyradius;
				break;
			case 2:
				joydata.x=-joyradius;
				joydata.y=0;
				break;
			case 3:
				joydata.x=-joyradius;
				joydata.y=joyradius;
				break;
			case 4:
				joydata.x=0;
				joydata.y=joyradius;
				break;
			case 5:
				joydata.x=joyradius;
				joydata.y=joyradius;
				break;
			case 6:
				joydata.x=joyradius;
				joydata.y=0;
				break;
			case 7:
				joydata.x=joyradius;
				joydata.y=-joyradius;
				break;
			}
		}

		if (user_action & DO_FIRE)
			joydata.buttonpressed[0]=1;

	}
}
*/

/*
 * DLGEnumerateCampaigns
 *
 * Stores the Campaign filenames in the passed in list box control.
 */
static	BOOL DLGEnumerateCampaigns( LPGUID lpGuid, DWORD buttonState, LPVOID lpv, char** lpFilenames, BOOL* pbFirstSelection  )
{
	TCHAR			filename[DLG_MAX_FILENAME + 1];
	HANDLE			hFileCtl;
	WIN32_FIND_DATA	fileData;
	int				nIndex;
	int				len;
	char*			pFileName;
	DWORD			bFileFound = FALSE;			// assume no files
    CWnd*			CWndCtl = (CWnd*) lpv;

	// clear the existing list
	DLGReleaseCampaignData( lpFilenames );
	SetPath(CAMPAIGN_PATH);

	// look to see which type of list to build
	nIndex      = 0;
	filename[0] = '\0';
	switch ( buttonState )
	{
	case DLG_NEW_MAP:
		// use the .CPN suffix
		strcat( filename, "*.CPN\0\0" );
		break;
	case DLG_USER_MAP:
		// use the .CPN suffix
		SetPath( MAP_PATH );
		strcat( filename, "*.AMM\0\0" );
		break;
	case DLG_LOAD_MAP:
		// use the .SAV suffix
		strcat( filename, "*.SAV\0\0" );
		break;
	case DLG_LAST_MAP:
		// use the .LST suffix
		strcat( filename, "*.LST\0\0" );
		break;
	case DLG_CAMPAIGN_MAP:
		// use the .CPN suffix
		strcat( filename, "*.CPN\0\0" );
		break;
	}

	// look for the first file with this suffix
	hFileCtl = FindFirstFile( filename, &fileData );
	if ( hFileCtl != INVALID_HANDLE_VALUE )
		bFileFound = TRUE;

	if ( gCWndCtlMaps == NULL )
			return( FALSE );

	// store this first file into the list box and then look for
	// others
	while ( bFileFound && (nIndex<DLG_MAX_FILES) )
	{
		len = strlen( fileData.cFileName );
		if ( len )
		{
			pFileName = (char*)malloc( len+1 );
			if ( !pFileName )
				return(FALSE);
			strcpy( pFileName, fileData.cFileName );
			lpFilenames[ nIndex ] = pFileName;
			++nIndex;
			if ( (buttonState == DLG_NEW_MAP) || (buttonState == DLG_CAMPAIGN_MAP) )
			{
				AiCampaignLoad( fileData.cFileName );
#ifdef CPN_DEBUG
				AiDumpCPN();
#endif
			}
			else
				DLGEnumFileName( gCWndCtlMaps->m_hWnd, fileData.cFileName, lpGuid, pbFirstSelection );
		}
		bFileFound = FindNextFile( hFileCtl, &fileData );
	}
	FindClose( hFileCtl );

	// now enumerate the data
	if ( buttonState == DLG_CAMPAIGN_MAP )
		DLGEnumGames( g_Campaigns, g_NumberCampaigns, gCWndCtlMaps, pbFirstSelection );

	// make sure the last filename in list is NULL
	lpFilenames[ nIndex ] = NULL;

    return(TRUE);
}

/*
 * DLGEnumGames
 *
 * Stores the Campaign filename information in the 
 * passed in list box control.
 */
static	BOOL DLGEnumGames( CAMPAIGNREF** pCampaignData, int nNumberCampaigns, LPVOID lpv, BOOL* pbFirstSelection  )
{
	LONG			iCampaign;
	CAMPAIGNREF*	pCampaign;
    CWnd*			CWndCtl = (CWnd*) lpv;
    HWND			hWndCtl = CWndCtl->m_hWnd;

	// insert each campaign
	for( iCampaign=0; iCampaign<nNumberCampaigns; ++iCampaign )
	{
		pCampaign = g_Campaigns[ iCampaign ];
		DLGEnumCampaign( hWndCtl, pCampaign->pCampaignName, pCampaign->nCampaignID,
			(iCampaign ? FALSE : TRUE ) );
	}

    return(TRUE);
}

/*
 * DLGEnumBattles
 *
 * Stores the Scenario and Mission filename information in the 
 * passed in list box control.
 */
static	BOOL DLGEnumBattles( SCENARIOREF* pScenarioData, LPVOID lpv, int nListIndex  )
{
	LONG			nID;
	LONG			iMission;
	SCENARIOREF*	pScenario;
	MISSIONREF*		pMission;
	HWND			hDlg;
    HWND			hListCtl;
	BOOL			bFirst = TRUE;
    CWnd*			CWndCtl = (CWnd*) lpv;
    HWND			hWndCtl = CWndCtl->m_hWnd;

	hDlg = GetParent( hWndCtl );
	if (hDlg == NULL)
		return(FALSE);

	 // insert scenario name in the list box item
	switch( nListIndex )
	{
	case 0:			// IDC_MISSIONS_0
		nID = IDC_MISSIONS_0;
		break;
	case 1:			// IDC_MISSIONS_1
		nID = IDC_MISSIONS_1;
		break;
	case 2:			// IDC_MISSIONS_2
		nID = IDC_MISSIONS_2;
		break;
	case 3:			// IDC_MISSIONS_3
		nID = IDC_MISSIONS_3;
		break;
	}
	hListCtl = GetDlgItem( hDlg, nID );

	// insert each scenario mission
	pScenario = pScenarioData;
	DLGEnumScenario( hDlg, pScenario->pScenarioName, pScenario->nScenarioID, nListIndex  );
	for( iMission=0; iMission<pScenario->nNumberMissions; ++iMission )
	{
		pMission = &(pScenario->pMissions[ iMission ]);
		DLGEnumMission( hListCtl, pMission->pMissionName, pMission->nMissionID, bFirst );
		bFirst = FALSE;
	}

    return(TRUE);
}

/*
 * DLGEnumCampaign
 *
 * Inserts session description information in the passed in 
 * tree view control.
 */
static	BOOL DLGEnumCampaign( HWND hWnd, LPTSTR pCampaignName, int nCampaignID, BOOL bFirst )
{
	int	nIndex;

    if (hWnd == NULL)
		return FALSE;

     // insert campaign name in the list box item
    nIndex = SendMessage(hWnd, LB_ADDSTRING, 0, (LPARAM) pCampaignName);

    // store the campaign ID as item data
	SendMessage(hWnd, LB_SETITEMDATA, nIndex, (LPARAM) nCampaignID);

    return(TRUE);
}

/*
 * DLGEnumScenario
 *
 * Inserts player information into the passed in tree view control.
 */
static	BOOL DLGEnumScenario( HWND hWnd, LPTSTR pScenarioName, int nScenarioID, int nListIndex  )
{
	HWND	hDlg;
	int		nID;

    if (hWnd == NULL)
		return FALSE;

     // insert scenario name in the list box item
	switch( nListIndex )
	{
	case 0:			// IDC_SCENARIO_TITLE_0
		nID = IDC_SCENARIO_TITLE_0;
		break;
	case 1:			// IDC_SCENARIO_TITLE_1
		nID = IDC_SCENARIO_TITLE_1;
		break;
	case 2:			// IDC_SCENARIO_TITLE_2
		nID = IDC_SCENARIO_TITLE_2;
		break;
	case 3:			// IDC_SCENARIO_TITLE_3
		nID = IDC_SCENARIO_TITLE_3;
		break;
	}
    SendDlgItemMessage(hWnd, nID, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0));
    SetDlgItemText(hWnd, nID, pScenarioName);

    // store the scenario ID as item data
	hDlg = GetDlgItem( hWnd, nID );
	SendMessage(hDlg, LB_SETITEMDATA, nListIndex, (LPARAM) nScenarioID);

    return(TRUE);
}

/*
 * DLGEnumMission
 *
 * Inserts player information into the passed in tree view control.
 */
static	BOOL DLGEnumMission( HWND hWnd, LPTSTR pMissionName, int nMissionID, BOOL pbFirstSelection )
{
	int	nIndex;

    if (hWnd == NULL)
		return FALSE;

     // insert campaign name in the list box item
    nIndex = SendMessage(hWnd, LB_ADDSTRING, 0, (LPARAM) pMissionName);

    // store the campaign ID as item data
	SendMessage(hWnd, LB_SETITEMDATA, nIndex, (LPARAM) nMissionID);

    return( TRUE );
}

/*
 * DLGEnumFileName
 *
 * Stores the Campaign filename information in the 
 * passed in list box control.
 */
static BOOL DLGEnumFileName(  HWND hWnd, LPTSTR lptFileName, LPGUID lpGuid, BOOL* pbFirstSelection )
{
	char		pFileName[ DLG_MAX_FILENAME + 1 ];
	char*		pName;
	int			nLen;
	LONG		iIndex;
    HTREEITEM	hItem;
	HTREEITEM	hr;

    if (hWnd == NULL)
		return FALSE;

	// strip the file suffix
	pName = (char*)lptFileName;
	nLen = strlen( pName );
	pName += (nLen-1);
	while( (*pName != '.') && (pName != (char*)lptFileName) )
	{
		--pName;
		--nLen;
	}
	if ( *pName == '.' )	// skip the suffix seperator
	{
		--pName;
		--nLen;
	}
	pName = (char*)lptFileName;
	for( iIndex=0; iIndex<nLen; ++iIndex )
	{
		pFileName[ iIndex ] = *pName;
		++pName;
	}
	pFileName[ iIndex ] = '\0';

    hItem = DLGAddListItem( hWnd, pFileName, (DWORD)lpGuid, 1 );
	if ( *pbFirstSelection == FALSE )
	{
		hr    = TreeView_SelectItem( hWnd, hItem );
		if ( hr == NULL )
			TRACE( "WARNING: TreeView_SelectItem failed\n" );
		else
			*pbFirstSelection = TRUE;
	}

    return(TRUE);
}

/*
 * DLGReleaseCampaignData
 *
 * Releases the memory allocated for campaign filename guids
 * depends on global variable ghWndSPControl
 */
static	void DLGReleaseCampaignData( char** lpFilenames )
{
    int count,index;

    if (gCWndCtlMaps)
    {
#if 0
		LPGUID lpGuid;
        count = gCWndCtlMaps->SendMessage( LB_GETCOUNT, 0, 0 );
        for (index = 0; index < count; index++)
        {
            lpGuid = (LPGUID) gCWndCtlMaps->SendMessage( LB_GETITEMDATA, index, 0 );
            if (lpGuid) free(lpGuid);
        }
#endif
        count        = gCWndCtlMaps->SendMessage( LB_RESETCONTENT, 0, 0 );
    }

	index = 0;
	for ( index=0;index<DLG_MAX_FILES; ++index )
	{
		if ( lpFilenames[ index ] )
		{
			free( (void*)(lpFilenames[ index ]) );
			lpFilenames[ index ] = NULL;
		}
	}
}

static int	DLGfindEditCtrl( CSliderCtrl* Cslider )
{
	CWnd*			Cparent;
	CSliderCtrl*	CObjectSlider;
	int				nSliderID = IDC_SFX_VOLUME_SLIDER;
	BOOL			bFound    = FALSE;
	BOOL			bDone     = FALSE;

	Cparent = Cslider->GetParentOwner();
	if ( Cparent == NULL )
	{
		nSliderID = 0;
		goto exit;
	}
	while (!bFound && !bDone )
	{
		CObjectSlider = (CSliderCtrl*)(Cparent->GetDlgItem( nSliderID ));
		if ( CObjectSlider )
		{
			if ( CObjectSlider == Cslider )
				bFound = TRUE;
		}
		switch( nSliderID )
		{
		case IDC_SFX_VOLUME_SLIDER:
			if ( !bFound )
				nSliderID = IDC_VOICE_VOLUME_SLIDER;
			break;
		case IDC_VOICE_VOLUME_SLIDER:
			if ( !bFound )
				nSliderID = IDC_MUSIC_VOLUME_SLIDER;
			break;
		case IDC_MUSIC_VOLUME_SLIDER:
			if ( !bFound )
				bDone = TRUE;
			break;
		}
	}
exit:
	return( nSliderID );
}

/*
 * CSliderCtlNotifyStrings
 *
 * output TRACE messages for the CSliderCtl OnNotify messages
 */
static void	CSliderCtlNotifyStrings( int nNotifyCode )
{
	switch( nNotifyCode )
	{
// CSliderCtl notify messages
	case TB_BOTTOM:			TRACE( "TB_BOTTOM - VK_END" ); break;
	case TB_ENDTRACK:		TRACE( "TB_ENDTRACK - WM_KEYUP, the user released a key that sent a relevant virtual-key code)\n" ); break;
	case TB_LINEDOWN:		TRACE( "TB_LINEDOWN - VK_RIGHT or VK_DOWN\n" ); break;
	case TB_LINEUP:			TRACE( "TB_LINEUP - VK_LEFT or VK_UP\n" ); break;
	case TB_PAGEDOWN:		TRACE( "TB_PAGEDOWN - VK_NEXT i.e.the user clicked the channel below or to the right of the slider)\n" ); break;
	case TB_PAGEUP:			TRACE( "TB_PAGEUP - VK_PRIOR (the user clicked the channel above or to the left of the slider)\n" ); break;
	case TB_THUMBPOSITION:	TRACE( "TB_THUMBPOSITION - WM_LBUTTONUP following a TB_THUMBTRACK notification message\n" ); break;
	case TB_THUMBTRACK:		TRACE( "TB_THUMBTRACK - Slider movement (the user dragged the slider)\n" ); break;
	case TB_TOP:			TRACE( "TB_TOP - VK_HOME\n" ); break;
	}
}

/*
 * CEditNotifyStrings
 *
 * output TRACE messages for the CButtonOnNotify messages
 */
static void	CEditNotifyStrings( int nNotifyCode )
{
	switch( nNotifyCode )
	{
// CEdit notify messages: edit boxes like enter name or percentage
	case EN_CHANGE:		TRACE( "EN_CHANGE - The user has taken an action that may have altered text in an edit control. Unlike the EN_UPDATE notification message, this notification message is sent after Windows updates the display.\n" ); break;
	case EN_ERRSPACE:	TRACE( "EN_ERRSPACE - The edit control cannot allocate enough memory to meet a specific request.\n" ); break;
	case EN_HSCROLL:	TRACE( "EN_HSCROLL - The user clicks an edit controls horizontal scroll bar. The parent window is notified before the screen is updated.\n" ); break;
	case EN_KILLFOCUS:	TRACE( "EN_KILLFOCUS - The edit control loses the input focus.\n" ); break;
	case EN_MAXTEXT:	TRACE( "EN_MAXTEXT - The current insertion has exceeded the specified number of characters for the edit control and has been truncated. Also sent when an edit control does not have the ES_AUTOHSCROLL style and the number of characters to be inserted would exceed the width of the edit control. Also sent when an edit control does not have the ES_AUTOVSCROLL style and the total number of lines resulting from a text insertion would exceed the height of the edit control.\n" ); break;
	case EN_SETFOCUS:	TRACE( "EN_SETFOCUS - Sent when an edit control receives the input focus.\n" ); break;
	case EN_UPDATE:		TRACE( "EN_UPDATE - The edit control is about to display altered text. Sent after the control has formatted the text but before it screens the text so that the window size can be altered, if necessary.\n" ); break;
	case EN_VSCROLL:	TRACE( "EN_VSCROLL - The user clicks an edit controls vertical scroll bar. The parent window is notified before the screen is updated.\n" ); break;
	}
}

/*
 * CListBoxNotifyStrings
 *
 * output TRACE messages for the CListBox OnNotify messages
 */
static void	CListBoxNotifyStrings( int nNotifyCode )
{
	switch( nNotifyCode )
	{
// CListBox notify messages: edit boxes like enter name or percentage
	case LBN_DBLCLK:	TRACE( "LBN_DBLCLK - The user double-clicks a string in a list box. Only a list box that has the LBS_NOTIFY style will send this notification message.\n" ); break;
	case LBN_ERRSPACE:	TRACE( "LBN_ERRSPACE - The list box cannot allocate enough memory to meet the request.\n" ); break;
	case LBN_KILLFOCUS:	TRACE( "LBN_KILLFOCUS - The list box is losing the input focus.\n" ); break;
	case LBN_SELCANCEL:	TRACE( "LBN_SELCANCEL - The current list-box selection is canceled. This message is only sent when a list box has the LBS_NOTIFY style.\n" ); break;
	case LBN_SELCHANGE:	TRACE( "LBN_SELCHANGE - The selection in the list box is about to change. This notification is not sent if the selection is changed by the CListBox::SetCurSel member function. This notification applies only to a list box that has the LBS_NOTIFY style. The LBN_SELCHANGE notification message is sent for a multiple-selection list box whenever the user presses an arrow key, even if the selection does not change.\n" ); break;
	case LBN_SETFOCUS:	TRACE( "LBN_SETFOCUS - The list box is receiving the input focus.\n" ); break;

	case WM_CHARTOITEM:	TRACE( "WM_CHARTOITEM - An owner-draw list box that has no strings receives a WM_CHAR message.\n" ); break;
	case WM_VKEYTOITEM:	TRACE( "WM_VKEYTOITEM - A list box with the LBS_WANTKEYBOARDINPUT style receives a WM_KEYDOWN message.\n" ); break;
	}  
}

/*
 * DLGNotifyStrings
 *
 * output TRACE messages for the OnNotify messages
 */
static void	DLGNotifyStrings( int nNotifyCode )
{
	TRACE( "OnNotify Code: %d\n", nNotifyCode );
}

/*
 * CButtonNotifyStrings
 *
 * output TRACE messages for the CButtonOnNotify messages
 */
static void	CButtonNotifyStrings( int nNotifyCode )
{
	switch( nNotifyCode )
	{
// CButton notify messages
	case BN_CLICKED:		TRACE( "BN_CLICKED - The user clicks a button.\n" ); break;
	case BN_DOUBLECLICKED:	TRACE( "BN_DOUBLECLICKED - The user double-clicks a button.\n" ); break;
	}
}


/*
OBSOLETE: I'm leaving this code here because it's a nice
example of how to extract frames from an anim

void calculatevehiclemasks(void)
{
	ANIM anim;
	SPRITE *pSprite;
	int angle, xintile, yintile;
	int curvehicle;

	int start,stop;

	unsigned char smalltempbuf[16][16];

	unsigned char tempbuf[65536];


	BYTE *oldSCRPTR;
	DWORD oldLPITCH;
	
	oldSCRPTR=SCRPTR;
	oldLPITCH=LPITCH;

	SCRPTR = &(tempbuf[0]);
	LPITCH = 256;
	ZeroMemory(vehiclemasks, sizeof(vehiclemasks));


	for (curvehicle=ARMY_JEEP; curvehicle<=ARMY_HALFTRACK; curvehicle++)
	{

		AnimSet( &anim, 0, 0, VehicleCommands[curvehicle], VSTOP_COMMAND, 0, ABSOLUTE_VELOCITY);
		AnimSetSize( &anim );

		for (angle=0;angle<32;angle++)
		{
//			pSprite=getanimsprite(&anim, VSTOP_COMMAND, angle*8);
			pSprite=AnimSprite(&anim, VSTOP_COMMAND, angle*8,  CURRENT_FRAME);

			ZeroMemory(tempbuf, 65536);

			DrawWRleClipped(0,0,(unsigned char *)(pSprite->pGraphic), pSprite->srect);

			for (xintile=0;xintile<4;xintile++)
				for (yintile=0;yintile<4;yintile++)
				{
					int xpixeloffset, ypixeloffset,x,y;

					ZeroMemory(smalltempbuf, sizeof(smalltempbuf));

					xpixeloffset=128+xintile*4+2-pSprite->hotspot.x;
					ypixeloffset=128+yintile*4+2-pSprite->hotspot.y;

					for (x=0;x<pSprite->srect.right;x++)
						for (y=0;y<pSprite->srect.bottom;y++)
							if (tempbuf[y*256+x]!=0 && tempbuf[y*256+x]!=17)
								smalltempbuf[(y+ypixeloffset)>>4][(x+xpixeloffset)>>4]=1;

					for (y=0;y<16;y++)
					{
						start=-1;
						stop=-1;
						for (x=0;x<16;x++)
							if (smalltempbuf[y][x])
							{
								if (start==-1)
									start=x;
								stop=x;
							}
		
						if (start==-1)
							vehiclemasks[curvehicle][angle][xintile][yintile][y]=64;
						else
							vehiclemasks[curvehicle][angle][xintile][yintile][y]=(start<<4)+stop;
					}




				}
					

		}
	}	

	SCRPTR=oldSCRPTR;
	LPITCH=oldLPITCH;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CGameStartDlg dialog

class CGameStartDlg : public CDialog
{
// Construction
public:
	CGameStartDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	BOOL	m_OnePlayerButton;
	BOOL	m_MultiPlayerButton;
	BOOL	m_OptionsButton;
	BOOL	m_QuitButton;
	BOOL	m_FirstButton;

	//{{AFX_DATA(CGameStartDlg)
	enum { IDD = IDD_GAME_START };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGameStartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGameStartDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
  	afx_msg void OnGameStartOnePlayerButton();
	afx_msg void OnGameStartMultiPlayerButton();
	afx_msg void OnGameStartOptionsButton();
	afx_msg void OnGameStartQuitButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CGameOptionsDlg dialog

class CGameOptionsDlg : public CDialog
{
// Construction
public:
	CGameOptionsDlg(CWnd* pParent = NULL);   // standard constructor

	void	SetSfxVolume( int nPercent );
	void	SetVoiceVolume( int nPercent );
	void	SetMusicVolume( int nPercent );

// Dialog Data
	BOOL	m_SfxOnOff;
	int		m_SfxVolume;
	BOOL	m_VoiceOnOff;
	int		m_VoiceVolume;
	BOOL	m_MusicOnOff;
	int		m_MusicVolume;

	//{{AFX_DATA(CGameOptionsDlg)
	enum { IDD = IDD_GAME_OPTIONS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGameOptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGameOptionsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSfxVolumeClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSfxOptionOff();
	afx_msg void OnSfxOptionOn();
	afx_msg void OnVoiceVolumeClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnVoiceOptionOff();
	afx_msg void OnVoiceOptionOn();
	afx_msg void OnMusicVolumeClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnMusicOptionOff();
	afx_msg void OnMusicOptionOn();
	afx_msg void OnGameOptionsCancel();
	afx_msg void OnGameOptionsOK();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


static void	DLGSetVolumeMember( CSliderCtrl* Cslider, int nCtrlID, int nPercent )
{
	CGameOptionsDlg*	Cparent;
	int					nEditID   = 0;
	BOOL				bFound    = FALSE;
	BOOL				bDone     = FALSE;

	Cparent = (CGameOptionsDlg*)Cslider->GetParentOwner();
	if ( Cparent == NULL )
		return;

	// set the position
	Cslider->SetPos( nPercent );
	switch( nCtrlID )
	{
	case IDC_SFX_VOLUME_SLIDER:
		Cparent->SetSfxVolume( nPercent );
		audioSetMasterVolume( SND_SFX_FLAG, (LONG)nPercent );
		break;
	case IDC_VOICE_VOLUME_SLIDER:
		Cparent->SetVoiceVolume( nPercent );
		audioSetMasterVolume( SND_VOICE_FLAG, (LONG)nPercent );
		break;
	case IDC_MUSIC_VOLUME_SLIDER:
		Cparent->SetMusicVolume( nPercent );
		audioSetMasterVolume( SND_MUSIC_FLAG, (LONG)nPercent );
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTitleDlg dialog


CTitleDlg::CTitleDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTitleDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTitleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CTitleDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTitleDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTitleDlg, CDialog)
	//{{AFX_MSG_MAP(CTitleDlg)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTitleDlg message handlers

BOOL CTitleDlg::OnInitDialog() 
{
	CRect	CRectWindow;
	CRect	CRectDialog;
	CWnd*	hCWndParent;
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	hCWndParent = GetParent();
	if ( hCWndParent == NULL )
		return( TRUE );
    hCWndParent->GetWindowRect( (LPRECT)&CRectWindow );
    GetWindowRect( (LPRECT)&CRectDialog );
	m_Offset.x = CRectWindow.left - CRectDialog.left;
	m_Offset.y = CRectWindow.top - CRectDialog.top;

    m_hCWndOnePlayer = GetDlgItem( IDC_ONEPLYR );
    if (m_hCWndOnePlayer == NULL)
		return(TRUE);
	else
		m_hCWndOnePlayer->GetWindowRect( (LPRECT)&m_hCRectOnePlayer );

    m_hCWndMultiPlayer = GetDlgItem( IDC_MULTIPLYR );
    if (m_hCWndMultiPlayer == NULL)
		return(TRUE);
	else
		m_hCWndMultiPlayer->GetWindowRect( (LPRECT)&m_hCRectMultiPlayer );

    m_hCWndOptions = GetDlgItem( IDC_OPTIONS );
    if (m_hCWndOptions == NULL)
		return(TRUE);
	else
		m_hCWndOptions->GetWindowRect( (LPRECT)&m_hCRectOptions );

    m_hCWndQuit = GetDlgItem( IDC_QUIT );
    if (m_hCWndQuit == NULL)
		return(TRUE);
	else
		m_hCWndQuit->GetWindowRect( (LPRECT)&m_hCRectQuit );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTitleDlg::OnMouseMove(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnMouseMove(nFlags, point);
}

void CTitleDlg::OnLButtonUp(UINT nFlags, CPoint point) 
{
	CPoint	offsetPoint;

	// TODO: Add your message handler code here and/or call default
	offsetPoint.x = point.x - m_Offset.x;
	offsetPoint.y = point.y - m_Offset.y;
	if ( m_hCRectOnePlayer.PtInRect( offsetPoint ) )
		CDialog::EndDialog( IDC_ONEPLYR );
	if ( m_hCRectMultiPlayer.PtInRect( offsetPoint ) )
		CDialog::EndDialog( IDC_MULTIPLYR );
	if ( m_hCRectOptions.PtInRect( offsetPoint ) )
		CDialog::EndDialog( IDC_OPTIONS );
	if ( m_hCRectQuit.PtInRect( offsetPoint ) )
	{
		MakeIdentityPalette( "Title_legal.bmp", &pMainFrame->GamePalette );
		CDialog::EndDialog( IDC_QUIT );
	}
	
	CDialog::OnLButtonUp(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
// CJoinArmySelectDlg dialog


CJoinArmySelectDlg::CJoinArmySelectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CJoinArmySelectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CJoinArmySelectDlg)
		// NOTE: the ClassWizard will add member initialization here
	m_ArmyState     = DLG_GREEN_BUTTON;		// initialize to a green army
	m_GreenButton   = DLG_BUTTON_ON;		// green army CHECKED
	m_TanButton     = DLG_BUTTON_OFF;		// tan army UNCHECKED
	m_BlueButton    = DLG_BUTTON_OFF;		// blue army UNCHECKED
	m_GreyButton    = DLG_BUTTON_OFF;		// grey army UNCHECKED
	//}}AFX_DATA_INIT
}


void CJoinArmySelectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CJoinArmySelectDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CJoinArmySelectDlg, CDialog)
	//{{AFX_MSG_MAP(CJoinArmySelectDlg)
	ON_BN_CLICKED(IDC_BLUE_ARMY, OnJoinArmySelectBlueArmy)
	ON_BN_CLICKED(IDC_GREEN_ARMY, OnJoinArmySelectGreenArmy)
	ON_BN_CLICKED(IDC_GREY_ARMY, OnJoinArmySelectGreyArmy)
	ON_BN_CLICKED(IDC_TAN_ARMY, OnJoinArmySelectTanArmy)
	ON_BN_CLICKED(IDCANCEL, OnJoinArmySelectCancel)
	ON_BN_CLICKED(ID_BACK, OnJoinArmySelectBack)
	ON_BN_CLICKED(ID_FINISH, OnJoinArmySelectFinish)
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CJoinArmySelectDlg message handlers

BOOL CJoinArmySelectDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	// acquire the input focus for this dialog
    gCWndOldFocus = SetFocus();
	
    // setup title fonts
    SendDlgItemMessage( IDC_CHOOSE_PLAYER_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0) );
    // set buttons
    SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton,  0 );
    SendDlgItemMessage( IDC_TAN_ARMY,   BM_SETCHECK, m_TanButton, 0 );
    SendDlgItemMessage( IDC_BLUE_ARMY,  BM_SETCHECK, m_BlueButton, 0 );
    SendDlgItemMessage( IDC_GREY_ARMY,  BM_SETCHECK, m_GreyButton, 0 );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CJoinArmySelectDlg::OnJoinArmySelectBack() 
{
	// TODO: Add your control notification handler code here
	CDialog::EndDialog( ID_BACK );
}

void CJoinArmySelectDlg::OnJoinArmySelectFinish() 
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
	CDialog::EndDialog( ID_FINISH );
}

void CJoinArmySelectDlg::OnJoinArmySelectCancel() 
{
	CDialog::OnCancel();
}

void CJoinArmySelectDlg::OnJoinArmySelectBlueArmy() 
{
	if ( pMainFrame->IsMultiPlayer() == FALSE )
		return;

	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_BLUE_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY, BM_SETCHECK, m_TanButton, 0 );
	m_BlueButton = TRUE;
	SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
	m_GreyButton = FALSE;
	SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
}

void CJoinArmySelectDlg::OnJoinArmySelectGreenArmy() 
{
	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_GREEN_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = TRUE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY, BM_SETCHECK, m_TanButton, 0 );
	if ( pMainFrame->IsMultiPlayer() )
	{
		m_BlueButton = TRUE;
		SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
		m_GreyButton = FALSE;
		SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
	}
}

void CJoinArmySelectDlg::OnJoinArmySelectGreyArmy() 
{
	if ( pMainFrame->IsMultiPlayer() == FALSE )
		return;

	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_GREY_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = FALSE;
	SendDlgItemMessage( IDC_TAN_ARMY, BM_SETCHECK, m_TanButton, 0 );
	m_BlueButton = FALSE;
	SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
	m_GreyButton = TRUE;
	SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
}

void CJoinArmySelectDlg::OnJoinArmySelectTanArmy() 
{
	// TODO: Add your control notification handler code here
	m_ArmyState = DLG_TAN_BUTTON;

	// now turn on the radial button for this HOST and turn
	// off the button for Join
	m_GreenButton = FALSE;
	SendDlgItemMessage( IDC_GREEN_ARMY, BM_SETCHECK, m_GreenButton, 0 );
	m_TanButton = TRUE;
	SendDlgItemMessage( IDC_TAN_ARMY, BM_SETCHECK, m_TanButton, 0 );
	if ( pMainFrame->IsMultiPlayer() )
	{
		m_BlueButton = TRUE;
		SendDlgItemMessage( IDC_BLUE_ARMY, BM_SETCHECK, m_BlueButton, 0 );
		m_GreyButton = FALSE;
		SendDlgItemMessage( IDC_GREY_ARMY, BM_SETCHECK, m_GreyButton, 0 );
	}
}

void CJoinArmySelectDlg::OnMove(int x, int y) 
{
	pMainFrame->UpdateView();
	CDialog::OnMove(x, y);
	CDialog::RedrawWindow( NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME); 
}

/////////////////////////////////////////////////////////////////////////////
// CTeamCreditsDlg dialog

class CTeamCreditsDlg : public CDialog
{
// Construction
public:
	CTeamCreditsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTeamCreditsDlg)
	enum { IDD = IDD_TEAM_CREDITS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTeamCreditsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTeamCreditsDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

void CAboutDlg::OnTeamCreditsButton() 
{
	int				result;
	CTeamCreditsDlg teamCreditsDlg;

	// TODO: Add your command handler code here
	result = teamCreditsDlg.DoModal();

	CDialog::OnOK();
	CDialog::EndDialog( result );
}


/////////////////////////////////////////////////////////////////////////////
// CJoinArmySelectDlg dialog

class CJoinArmySelectDlg : public CDialog
{
// Construction
public:
	CJoinArmySelectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	int		m_ArmyState;
	BOOL	m_GreenButton;
	BOOL	m_TanButton;
	BOOL	m_BlueButton;
	BOOL	m_GreyButton;

	//{{AFX_DATA(CJoinArmySelectDlg)
	enum { IDD = IDD_JOIN_ARMY_SELECT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJoinArmySelectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CJoinArmySelectDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnJoinArmySelectBlueArmy();
	afx_msg void OnJoinArmySelectGreenArmy();
	afx_msg void OnJoinArmySelectGreyArmy();
	afx_msg void OnJoinArmySelectTanArmy();
	afx_msg void OnJoinArmySelectCancel();
	afx_msg void OnJoinArmySelectBack();
	afx_msg void OnJoinArmySelectFinish();
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#define	DLG_NEW_MAP			0
#define	DLG_USER_MAP		1
#define	DLG_LOAD_MAP		2
#define	DLG_LAST_MAP		3
#define	DLG_CAMPAIGN_MAP	4

#define	DLG_GREEN_BUTTON	0
#define	DLG_TAN_BUTTON		1
#define	DLG_BLUE_BUTTON		2
#define	DLG_GREY_BUTTON		3

/////////////////////////////////////////////////////////////////////////////
// CTitleDlg dialog

class CTitleDlg : public CDialog
{
// Construction
public:
	CTitleDlg(CWnd* pParent = NULL);   // standard constructor

	CWnd*	m_hCWndOnePlayer;
	CWnd*	m_hCWndMultiPlayer;
	CWnd*	m_hCWndOptions;
	CWnd*	m_hCWndQuit;
	CRect	m_hCRectOnePlayer;
	CRect	m_hCRectMultiPlayer;
	CRect	m_hCRectOptions;
	CRect	m_hCRectQuit;

	POINT	m_Offset;

// Dialog Data
	//{{AFX_DATA(CTitleDlg)
	enum { IDD = IDD_TITLE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTitleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTitleDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

int CJoinSessionDlg::OnJoinArmySelectDialog() 
{
	int					result  = IDCANCEL;
	int					result2  = IDCANCEL;
	CJoinArmySelectDlg	armySelectDlg;
	CJoinLobby            joinLobbyDlg;
	// TODO: Add your command handler code here
	result = armySelectDlg.DoModal();
    
    if ( (result == ID_FINISH) && (gpComm->IsDPlay()) )	// was communication initialized correctly ?
    {
 			// if so, launch game
			TRACE("communications initialized...launch Game\n");
	        pMainFrame->PostMessage( UM_TDG_LAUNCH, 0, 0 );
    }
    else 
    {
        // otherwise, abort game
		TRACE("communications failed to initialized...Abort Game\n");
        pMainFrame->PostMessage( UM_TDG_ABORT, 0, 0 );
    }

	return( result );
}

///========================================================================
//	Function:		ArmyGenerateMessage()
//	Description:	Retrieve the PLAYER or ENEMY units.
///========================================================================

void	ArmyGenerateMessage( ARMY_TYPE eArmy, ITEM* pItem, int nPriority )
{
	int	eObjType;

	eObjType = ITEM_TYPE( pItem );
	if ( (eArmy == ARMY_PLAYER) && ( eObjType == ARMY_UNIT) && (nPriority != ARMY_NO_ACTION) )
		MsgSend( (void*)pItem, nPriority );
}


///========================================================================
//	Function:		MsgTest()
//
//	Description:
//		send a message from the currently active unit object.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void	MsgTest( UINT nChar, UINT nFlags )
{
	ITEM*		pItem;
	int			nAction;
	ARMY_TYPE	eArmy;

	// do we have a currently selected unit?
	if ( curselectedunit )
	{
		// find the item for this unit.
		pItem = (ITEM*)curselectedunit;
		eArmy = ITEM_ARMY( pItem );

		// pick a random message
		nAction = rand() % ARMY_LAST_ACTION;

		// send the message
		if ( nAction != ARMY_NO_ACTION )
		ArmyGenerateMessage( eArmy, pItem, nAction );
	}
}

///========================================================================
//	Function:		MsgSend()
//
//	Description:
//		Terminate the MSG processor.
//
//	Input:			pUnit		unit whose sending the message
//					eAction		action basis of message
//
//	Ouput:			none
//
///========================================================================

void		MsgSend( void* pUnit, int eAction )
{
	char		Message[ 128];
	MSG_BLOCK**	msgIds;
	ULONG		sectorID;
	ULONG		audioID;
	int			eObjType;
	int			index;
	int			nTarget;
	ITEM*		pTargetItem;
	MESSAGE*	pLastMessage;
	ITEM*		pItem;
	BOOL		bReportFoe;

	// verify the parameters and initialize
	ASSERT( pUnit );
	nTarget      = ARMY_NULL_OBJ;
	pTargetItem  = NULL;
	pLastMessage = &(((UNIT*)pUnit)->lastMessage);
	pItem        = (ITEM*)pUnit;
	bReportFoe   = TRUE;

	// first acquire any target info
	pTargetItem = AiMyTargetObject( pItem );
	if ( pTargetItem )
		nTarget = ITEM_TYPE( pTargetItem );

	// determine whether or not this new situation will require a new message
	if ( MsgIsSimilar( pLastMessage, eAction, nTarget ) )
		return;

	// if here then we're creating a new message. Better release any existing
	// audio.
	if ( pLastMessage->msgAudioID != SND_NULL_SND_ID )
		MsgDelete( (void*)pItem );

	// Squad Message Format
	// <unit ID><action><foe>[<sector>]
	//
	// where <unit ID>     = <long Name> | <short Name>
	//       <action>      = UNDER_ATTACK | ATTACKING |
	//                       ELIMINATED | ENGAGED | DISENGAGE |
	//                       APPROACHING | CASUALTIES | REACHED
	//       <foe>         = <enemy squad> | <object> | NULL
	//       <sector>      = <column><row>
	//       <long Name>   = squad long name string
	//       <short Name>  = squad short name string
	//       <enemy squad> = <color><foe Name>
	//       <object>      = <asset> | <structure>
	//       <column>      = "A" | "B" | ... | "L"  | "M"
	//       <row>         = "1" | "2" | ... | "12" | "13"
	//       <color>       = "green" | "tan" | "blue" | "grey"
	//       <foe Name>    = squad foe name string
	//       <asset>       = asset name string
	//       <structure>   = object structure name string

	// store the situation and target values
	msgIds                    = pLastMessage->msgIDs;
	pLastMessage->msgPriority = eAction;
	pLastMessage->msgTarget   = nTarget;

	// clear the MSG_BLOCKs
	for ( index=0; index<MSG_MAX_LINKS; ++index )
		msgIds[index ] = NULL;

	// acquire the object name ID
	index = 0;
	if ( MsgObjectNameID( pItem, msgIds, &index ) )
		return;

	// acquire the action ID
	msgIds[ index++ ] = &(MsgActions[ eAction ]);
	switch( eAction )
	{
	case ARMY_NO_ACTION:
		goto exit;
		break;
	case ARMY_UNDER_ATTACK:
	case ARMY_ATTACKING:
	case ARMY_ELIMINATED:
	case ARMY_ENGAGED:
		sectorID   = MSG_IN_SECTOR;
		break;
	case ARMY_DISENGAGED:
		sectorID = MSG_NO_SECTOR;
		break;
	case ARMY_APPROACH:
		sectorID = MSG_FROM_SECTOR;
		break;
	case ARMY_SUFFERING:
		sectorID   = MSG_IN_SECTOR;
		bReportFoe = FALSE;
		break;
	case ARMY_REACHED:
		sectorID   = MSG_JUST_SECTOR;
		bReportFoe = FALSE;
		break;
	default:
		TRACE( "ERROR: unknown Action type (%d)\n", eAction );
		ASSERT(0);
	}

	// acquire the Foe ID
	if ( bReportFoe )
		if ( MsgObjectFoeID( pItem, msgIds, &index ) )
			return;

	// acquire the sector ID
	if ( sectorID && pTargetItem )
		sectorID = MsgObjectSectorID( pTargetItem, sectorID, msgIds, &index );

	// force a terminator into the Msg stream

#ifdef MSG_DEBUG
	TRACE( "Message Strings:\n" );
	for( index=0; index<MSG_MAX_LINKS; ++index )
	{
		if ( msgIds[ index ] )
			TRACE( "    (%ld): \"%s\"\n", msgIds[ index ]->nSound, msgIds[ index ]->pString );
	}

#endif

	// build the audio message
	audioID = MsgBuildAudio( msgIds );

	// build the Text Message
	MsgBuildPrintable( msgIds, Message );

	// play the audio stream
	pLastMessage->msgAudioID = audioID;
	if ( audioID != SND_NULL_SND_ID )
		sndPlay( pLastMessage->msgAudioID );

	// send this message to the dashboard
	eObjType = ITEM_TYPE( pItem );
	if ( eObjType == ARMY_UNIT )
		ReceiveDashMessage( Message, (OBJECT*)pItem );

exit:
	return;
}

///========================================================================
//	Function:		MsgReplay()
//
//	Description:
//		Replay the last message
//
//	Input:			pUnit		the unit whose message the dashboard needs to display
//
//	Ouput:			none
//
///========================================================================

void	MsgReplay( void* pUnit )
{
	char	Message[ 128 ];
	int		eObjType;
	MESSAGE* pLastMessage;
	ITEM*	pItem;

	// verify the parameter and initialize
	ASSERT( pUnit );
	pLastMessage = &(((UNIT*)pUnit)->lastMessage);
	pItem        = (ITEM*)pUnit;

	// build the Text Message
	MsgBuildPrintable( pLastMessage->msgIDs, Message );

	// send this message to the dashboard
	eObjType = ITEM_TYPE( pItem );
	if ( eObjType == ARMY_UNIT )
		ReceiveDashMessage( Message, (OBJECT*)pItem );
}

///========================================================================
//	Function:		MsgDelete()
//
//	Description:
//		Terminate the MSG processor.
//
//	Input:			pUnit		unit whose last message is to be deleted
//
//	Ouput:			none
//
///========================================================================

void	MsgDelete( void* pUnit )
{
	MESSAGE*	pLastMessage;

	// validate the paramter
	ASSERT( pUnit );
	pLastMessage = &(((UNIT*)pUnit)->lastMessage);

	// stop the sound if its playing
	sndHalt(pLastMessage->msgAudioID);

	// now delete the sound
	audioDelete(pLastMessage->msgAudioID);

	// clear the sound id
	pLastMessage->msgAudioID = SND_NULL_SND_ID;
}


///========================================================================
//	Function:		MsgBuildPrintable()
//
//	Description:
//		Build the printable unit last message.
//
//	Input:			pTheUnit		the Unit whose message we want
//					pMsgBuffer		where to store the formated text 
//
//	Ouput:			none
//
///========================================================================

void		MsgBuildPrintable( MSG_BLOCK** pMsgIds, char* pMsgBuffer )
{
	int	index;
	int	len;

	// Parse through the msg IDs, skipping those with value MSG_EMPTY. The
	// terminator will be MSG_NULL. make sure you don't exceed the maximum
	// link size
	*pMsgBuffer = '\0';
	index       = 0;
	while( (pMsgIds[ index ] != NULL) && (index<MSG_MAX_LINKS) )
	{
		// only include non-MSG_EMPTY and non SND_NULL_SND_ID)
		if ( (pMsgIds[ index ]->nSound != MSG_NULL) &&
			 (pMsgIds[ index ]->nSound != MSG_EMPTY) )
		{
			// add this message ID to the list
			strcat( pMsgBuffer, pMsgIds[ index ]->pString );

			// insert a blank and line terminator
			strcat( pMsgBuffer, " \0" );
		}

		// advance to the next msg id
		++index;
	}
	len = strlen( pMsgBuffer );
}

///========================================================================
//	Function:		MsgGetObjectName()
//
//	Description:
//		acquire the object name including its army color.
//
//	Input:			pItem		Item whose name we want
//					pName		where to store the name
//
//	Ouput:			none
//
///========================================================================

void MsgGetObjectName( void* pItem, char* pName )
{
	ARMY_TYPE	eArmy;
	MSG_BLOCK*	pColor;
	MSG_BLOCK*	pObjName;
	MSG_BLOCK	msgId;
	int			index;

	// verify the parameters and initialize
	ASSERT( pItem );
	ASSERT( pName );

	// initialize the string
	*pName = '\0';

	// first acquire army for color
	eArmy  = ITEM_ARMY( (ITEM*)pItem );
	pColor  = NULL;
	if ( (eArmy >= ARMY_PLAYER) && (eArmy <= ARMY_PLAYER_4) )
		pColor = &(MsgColors[ eArmy ]);

	// acquire the object name ID
	index    = 0;
	pObjName = &msgId;
	if ( MsgObjectNameID( (ITEM*)pItem, &pObjName, &index ) )
		return;

	if ( pColor )
		sprintf(pName, "%s %s", pColor->pString, pObjName->pString);
	else
		sprintf(pName, "%s", pObjName->pString);
}

///========================================================================
//	Function:		MsgInit()
//
//	Description:
//		Initialize the MSG processor
//
//	Input:			none
//
//	Ouput:			error		TRUE if successful, FALSE otherwise
//
///========================================================================

BOOL		MsgInit( void )
{
	BOOL		error = TRUE;	// assume failure


	nMsgEdgeZone = 24;

	// we made it here, success
	error = FALSE;

	return( error );
}

///========================================================================
//	Function:		MsgExit()
//
//	Description:
//		Terminate the MSG processor.
//
//	Input:			none
//
//	Ouput:			none
//
///========================================================================

void		MsgExit( void )
{
}


///========================================================================
//	Function:		MsgObjectSectorID()
//
//	Description:
//		return the Foe Name ID for this object.
//
//	Input:			pItem		the object whose name we wish to find
//					sectorID	type of sector message
//					pMsgIds		array of message IDS
//					pIndex		current index to load ids
//
//	Ouput:			none
//
///========================================================================

BOOL	MsgObjectSectorID( ITEM* pItem, ULONG sectorID, MSG_BLOCK** pMsgIds, int* pIndex )
{
	SPOINT*		pPosition;
	int			nRow;
	int			nColumn;
	BOOL		error = TRUE;

	// first load the sector string
	pMsgIds[ *pIndex ] = MsgSectorNames[ sectorID ];
	++(*pIndex );

	// get the objects position and determine the sector coodinates
	pPosition = AiPosition( pItem->nUniqueID, FALSE );
	ASSERT( pPosition );

	if ( MsgPoint2Sector( pPosition, &nRow, &nColumn ) )
		goto exit;

	// Load the sector Column string i.e. A, B, C, ... )
	pMsgIds[ *pIndex ] = &(MsgColumnNames[ nColumn ]);
	++(*pIndex );

	// Load the sector Row string
	pMsgIds[ *pIndex ] = &(MsgRowNames[ nRow ]);
	++(*pIndex );

exit:
	return( error );
}

///========================================================================
//	Function:		MsgPoint2Sector()
//
//	Description:
//		return the Name ID for this object.
//
//	Input:			pObject		the object whose name we wish to find
//					pRow		resultant row coordinate for a sector
//					pColumn		resultant column coordinate for a sector
//
//	Ouput:			nRow		Sector row coordinate
//					nColumn		Sector column coordinate
//
///========================================================================

BOOL	MsgPoint2Sector( SPOINT* pPosition, int* nRow, int* nCol )
{
	// for now sectors are 32 x 32 tiles, and tiles are 16 x 16 points
	// therefore, to convert from point to tile coordinates means
	// shifting first >> 4, for the 16. Then again by >> 5 for the 32.
	// Or simply >> 9
	*nRow = ((pPosition->x) >> 9);
	*nCol = ((pPosition->y) >> 9);

	return( FALSE );
}


///========================================================================
//	Function:		MsgIsSimilar()
//
//	Description:
//		determine if the new situation and target is similiar enough to
//		the existing values that we can ignore it..
//
//	Input:			pLastMessage	last message to check
//					nPriority		determines the priority of the message
//					target			possible target segment specifier
//
//	Ouput:			TRUE			if similiar, FALSE otherwise
//
///========================================================================

BOOL		MsgIsSimilar( MESSAGE* pLastMessage, ULONG nPriority, UINT target )
{
	ULONG	unitPriority;
	UINT	unitTarget;
	BOOL	similiar = TRUE;		// assume they are similar

	// get the units existing values
	unitPriority = pLastMessage->msgPriority;
	unitTarget   = pLastMessage->msgTarget;

	// see if the situations are similiar
	if ( nPriority == unitPriority )
	{
		// now see if the target has changed
		if ( (unitTarget || target) )
			if ( target == unitTarget )
				goto exit;
		else
			goto exit;
	}

	// if we're here we can assume that we are gonna generate a new message
	similiar  = FALSE;

exit:
	return( similiar );
}

///========================================================================
//	Function:		MsgObjectNameID()
//
//	Description:
//		return the Name ID for this object.
//
//	Input:			pItem		the object whose name we wish to find
//					pMsgIds		array of message IDS
//					pIndex		current index to load ids
//
//	Ouput:			none
//
///========================================================================

BOOL	MsgObjectNameID( ITEM* pItem, MSG_BLOCK** pMsgIds, int* pIndex )
{
	ITEM_TYPE	eObjType;
	int			eUnitType;
	int			eUnitID;
	UNIT_BLOCK*	pUnitNames;
	int			nNameID;
	BOOL		error = TRUE;

	// first determine which type of object this is
	eObjType = ITEM_TYPE( pItem );

	// acquire the name based on the object type
	switch(eObjType)	{
		case ARMY_UNIT:
			// get the unit type and the unit index
			eUnitType = ITEM_CLASS( pItem );
			eUnitID   = ITEM_INDEX( pItem );

			pUnitNames = UnitIdNames[ eUnitType ];
			pMsgIds[ *pIndex ] = &(pUnitNames[ eUnitID ].pLongName);
			++(*pIndex);

			error = FALSE;
			break;
		case ARMY_SARGE:
			pMsgIds[ *pIndex ] = &(MsgVehicleNames[ ARMY_COMMANDER ]);
			++(*pIndex);
			error = FALSE;
			break;
		case ARMY_VEHICLE:
			nNameID = ITEM_CLASS( pItem );
			pMsgIds[ *pIndex ] = &(MsgVehicleNames[ nNameID ]);
			++(*pIndex);
			error = FALSE;
			break;
		case ARMY_STRUCTURE:
		case ARMY_OBSTACLE:
		case ARMY_ASSET:
			nNameID = ITEM_CLASS( pItem );
			pMsgIds[ *pIndex ] = &(MsgObjectNames[ nNameID ]);
			++(*pIndex);
			error = FALSE;
			break;
	}

	return( error );
}


///========================================================================
//	Function:		MsgObjectFoeID()
//
//	Description:
//		return the Foe Name ID for this object.
//
//	Input:			pItem		the object whose name we wish to find
//					pMsgIds		array of message IDS
//					pIndex		current index to load ids
//
//	Ouput:			none
//
///========================================================================

BOOL	MsgObjectFoeID( ITEM* pItem, MSG_BLOCK** pMsgIds, int* pIndex )
{
	ITEM_TYPE	eObjType;
	UNIT_BLOCK*	pUnitNames;
	int			eObjClass;
	int			eUnitType;
	int			eUnitID;
	BOOL		error = TRUE;

	// first determine which type of object this is
	eObjType = ITEM_TYPE( pItem );

	switch(eObjType)	{
		case ARMY_UNIT:
			// get the unit type and the unit index
			eUnitType = ITEM_CLASS( pItem );
			eUnitID   = ITEM_INDEX( pItem );

			pUnitNames = UnitIdNames[ eUnitID ];
			pMsgIds[ *pIndex ] = &(pUnitNames[ eUnitID ].pFoeName);
			++(*pIndex);

			error = FALSE;
			break;
		case ARMY_SARGE:
			break;
		case ARMY_VEHICLE:
			break;
		case ARMY_STRUCTURE:
		case ARMY_OBSTACLE:
		case ARMY_ASSET:
			eObjClass = ITEM_CLASS( pItem );
			pMsgIds[ *pIndex ] = &(MsgObjectNames[ eObjClass ] );
			++(*pIndex);
			error = FALSE;
			break;
	}

	return( error );
}

///========================================================================
//	Function:		MsgBuildAudio()
//
//	Description:
//		Build the audio portion of unit last message, returning the appropriate
//		SND id. NOTE: The audio IDs must be one-to-one with the msg IDs plus
//		some offset.
//
//	Input:			pMsgIds			the Unit message ids that form the audio stream
//
//	Ouput:			none
//
///========================================================================

ULONG		MsgBuildAudio( MSG_BLOCK** pMsgIds )
{
	ULONG		links[MSG_MAX_LINKS+1];
	ULONG		audioID;
	int			id;
	int			index;

	// Parse through the msg IDs, skipping those with value MSG_EMPTY. The
	// terminator will be MSG_NULL. make sure you don't exceed the maximum
	// link size
	id        = 0;
	index     = 0;
	while( (pMsgIds[ index ] != NULL) && (id<MSG_MAX_LINKS) )
	{
		// only include non-MSG_EMPTY and non SND_NULL_SND_ID)
		if ( (pMsgIds[ index ]->nSound != MSG_NULL) &&
			 (pMsgIds[ index ]->nSound != MSG_EMPTY) )
		{
			// add this message ID to the list
			links[ id ] = pMsgIds[ index ]->nSound;

			// advance to the next link location
			++id;
		}

		// advance to the next msg id
		++index;
	}

	// insert a terminator for SND
	links[ id ] = (ULONG)AUDIO_NULL_SOUND;

	// now create the audio ID for this stream link
	audioID = audioCreateLink( AUDIOstreamID, links, (SND_STREAM_FLAG|SND_VOICE_FLAG) );
	if ( audioID == SND_NULL_SND_ID )
	{
		// report an error
		TRACE("ERROR: failed to link sounds. [%s:%d]\n", 
			__FILE__, __LINE__ );
		goto exit;
	}
	audioStoreSnd( links[0], audioID, (SND_STREAM_FLAG|SND_VOICE_FLAG) );

exit:
	return( audioID );
}

/*==========================================================================
 *
 *  From lobby.c
 *
 *
 ***************************************************************************/


// and from 3doNetwork.cpp

/*
 * LaunchedByLobby
 *
 * Determines if we were launched by a lobby. If so, gets the connection settings
 * and creates our player using the information from the lobby
 */
BOOL LaunchedByLobby(void)
{
    HRESULT hr;
    HWND    hwndStatus;

    // create a lobby object
    hr = gpComm->LobbyCreate();
    if (FAILED(hr))
    {
        ShowError(IDS_DPLOBBY_ERROR_C);
        return FALSE;
    }

    // get connection settings from the lobby (into gpComm->m_pConnection)
    hr = gpComm->LobbyGetConnectionSettings();
    if (FAILED(hr))
    {
        if (DPERR_NOTLOBBIED == hr)
        {
            // we were not lobbied - start up game normally
            hr = gpComm->LobbyRelease();
            if (FAILED(hr))
            {
                ShowError(IDS_DPLOBBY_ERROR_R);
                goto FAIL;
            }
            // move on
            return FALSE;
        }
        else
        {
            ShowError(IDS_DPLOBBY_ERROR_GCS);
            goto FAIL;
        }
    }

    // are we hosting or joining ?
    if (gpComm->m_pConnection->dwFlags & DPLCONNECTION_CREATESESSION)
    {
        gpComm->m_bHost  = TRUE;
		gpGame->GameType = GAMETYPE_HOST_MULTIPLAYER;
    }

    // set our session flags
    gpComm->m_pConnection->lpSessionDesc->dwFlags = DPSESSION_MIGRATEHOST | 
                                                 DPSESSION_KEEPALIVE;

    // let lobby know our connection flags
    hr = gpComm->LobbySetConnectionSettings();
    if (FAILED(hr))
    {
        ShowError(IDS_DPLOBBY_ERROR_SCS);
        goto FAIL;
    }

    if ( gpComm->m_bHost ) 
    {
        // show splash screen and 
        // connection status if we are joining a game
        UpdateWindow(ghWndMain);
        hwndStatus = ShowConnectStatus();
    }
    else
    {
        // we are hosting, don't need connection status
        hwndStatus = NULL;
    }

    // connect to the lobby
    hr = gpComm->LobbyConnect();

    if ( hwndStatus )
    {
        // get rid of the connectino status window
        DestroyWindow(hwndStatus);
    }

    if (FAILED(hr))
    {
        ShowError(IDS_DPLOBBY_ERROR_CONNECT);
        goto FAIL;
    }

    // create our player
    hr = gpComm->CreatePlayer(
                          
#ifdef UNICODE
                            gpComm->m_pConnection->lpPlayerName->lpszShortName,
#else
                            gpComm->m_pConnection->lpPlayerName->lpszShortNameA,
#endif
                            NULL,
                            NULL,
                            0
                          );

    if (FAILED(hr))
    {
        ShowError(IDS_DPLAY_ERROR_CP);
        goto FAIL;
    }


    // cleanup
    hr = gpComm->LobbyRelease();
    if (FAILED(hr))
    {
        ShowError(IDS_DPLOBBY_ERROR_R);
        goto FAIL;
    }

    // we were lobbied
    return TRUE;

FAIL:
    // cleanup and exit
    gpComm->LobbyRelease();
    ExitGame();
    return FALSE;
}

//
// LobbySetConnectionSettings
//
// Wrapper for DirectPlayLobby SetConnectionSettings API
//


HRESULT CComm::LobbySetConnectionSettings(void)
{
    HRESULT hr=E_FAIL;
    hr = IDirectPlayLobby_SetConnectionSettings(m_pLobby, 0, 0, m_pConnection);
    return hr;
}
/*
 * LobbyGetConnectionSettings
 *
 * Wrapper for DirectPlayLobby GetConnectionSettings API
 */
HRESULT CComm::LobbyGetConnectionSettings(void)
{
    HRESULT hr=E_FAIL;
    DWORD dwSize;

    if (m_pLobby)
    {
        // get size for the connection settings structure
        hr = IDirectPlayLobby_GetConnectionSettings(m_pLobby, 0, NULL, &dwSize);
        if (DPERR_BUFFERTOOSMALL == hr)
        { 
            // if we already have one, free it
            if (m_pConnection)
            {
                free(m_pConnection);
                m_pConnection = NULL;
            }

            // allocate memory for the new one
            m_pConnection = (LPDPLCONNECTION) malloc(dwSize);

            // get the connection settings
            if (m_pConnection)
                hr = IDirectPlayLobby_GetConnectionSettings(m_pLobby, 0, m_pConnection, &dwSize);
        }
    }

    return hr;
}

/*
 * LobbyConnect
 *
 * Wrapper for DirectPlayLobby Connect API.
 */
HRESULT CComm::LobbyConnect(void)
{
    HRESULT hr=E_FAIL;

    // hr = IDirectPlayLobby_Connect(m_pLobby, 0, &m_pDPlay, NULL) ;    

    return hr;
}
/*
 * LobbyCreate
 *
 * Wrapper for DirectPlayLobby DirectPlayLobbyCreate API.
 */
HRESULT CComm::LobbyCreate(void)
{
    HRESULT hr=E_FAIL;

    // hr = DirectPlayLobbyCreate(NULL, &m_pLobby, NULL, NULL, 0);   

    return hr;
}




